<!-- This file contains the setup header for the publications list -->

<html>

<head>
<title>Stephanie Weirich's Publications</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-20228260-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<!-- Change these colors to match the ones generated by FrontPage -->
<!-- <body bgcolor="#000000" link="#800000" vlink="#800000" alink="#800000"> -->
<center>
<table border="0" cellpadding="3" cellspacing="3" width="800">
<tr>
<td width="100%" class="yellow" valign="middle" align="left">
<font size="5">
Stephanie Weirich's Publications
</font><br>
<a href="#COPY">Copyright Information</a>
</td>
</tr>


<tr><td width=100% class=lightaqua valign=middle align=left>
<font size=4>Works in Progress</font>

<!-- This document was automatically generated with bibtex2html 1.96
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s boldtitle -nodoc -d -r -both -nobibsource -nf ps PS -nf pdf PDF -nf projecturl Project unpub.bib  -->


<table></table><hr>

</td></tr>
<tr><td width=100% class=lightaqua valign=middle align=left>
<font size=4>Conferences and Workshops</font>

<!-- This document was automatically generated with bibtex2html 1.96
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s boldtitle -nodoc -d -r -both -nobibsource -nf ps PS -nf pdf PDF -nf projecturl Project conf.bib  -->


<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="breitner:safe-coercions">1</a>]
</font></td>
<td class="bibtexitem">
Joachim Breitner, Richard&nbsp;A. Eisenberg, Simon Peyton Jones, and Stephanie
  Weirich.
 <b>Safe Zero-Cost Coercions for Haskell</b>.
 In <em>The 19th ACM SIGPLAN International Conference on Functional
  Programming</em>, ICFP '14, September 2014.
 To appear.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/coercible.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="eisenberg:closed-tf">2</a>]
</font></td>
<td class="bibtexitem">
Richard&nbsp;A. Eisenberg, Dimitrios Vytiniotis, Simon Peyton Jones, and Stephanie
  Weirich.
 <b>Closed type families with overlapping equations</b>.
 In <em>POPL 2014: 41st ACM SIGPLAN-SIGACT Symposium on Principles of
  Programming Languages</em>, pages 671-683, San Diego, CA, USA, 2014.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="casinghino:combining-proofs-programs">3</a>]
</font></td>
<td class="bibtexitem">
Chris Casinghino, Vilhelm Sj&ouml;berg, and Stephanie Weirich.
 <b>Combining Proofs and Programs in a Dependently Typed Language</b>.
 In <em>POPL 2014: 41st ACM SIGPLAN-SIGACT Symposium on Principles of
  Programming Languages</em>, pages 33-45, San Diego, CA, USA, 2014.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:dwk">4</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich, Justin Hsu, and Richard&nbsp;A. Eisenberg.
 <b>System FC with explicit kind equality</b>.
 In <em>Proceedings of The 18th ACM SIGPLAN International Conference
  on Functional Programming</em>, ICFP '13, pages 275-286, Boston, MA, 2013.

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="sparcs">5</a>]
</font></td>
<td class="bibtexitem">
Miroslav Pajic, Nicola Bezzo, James Weimer, Rajeev Alur, Rahul Mangharam,
  Nathan Michael, George&nbsp;J. Pappas, Oleg Sokolsky, Paulo Tabuada, Stephanie
  Weirich, and Insup Lee.
 <b>Towards synthesis of platform-aware attack-resilient control
  systems: extended abstract</b>.
 In <em>HiCoNS '13: Proceedings of the 2nd ACM international
  conference on High confidence networked systems</em>, pages 75-76, New York, NY,
  USA, 2013.
[&nbsp;<a href="http://doi.acm.org/10.1145/2461446.2461457">DOI</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="eisenberg:singletons">6</a>]
</font></td>
<td class="bibtexitem">
Richard&nbsp;A. Eisenberg and Stephanie Weirich.
 <b>Dependently typed programming with singletons</b>.
 In <em>Haskell Symposium</em>, pages 117-130, Copenhagen, Denmark,
  September 2012.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/haskell12.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="ccasin:msfp12">7</a>]
</font></td>
<td class="bibtexitem">
Chris Casinghino, Vilhelm Sj&ouml;berg, and Stephanie Weirich.
 <b>Step-Indexed Normalization for a Language with General
  Recursion</b>.
 In <em>Fourth workshop on Mathematically Structured Functional
  Programming (MSFP '12)</em>, pages 25-39, 2012.
[&nbsp;<a href="papers/msfp12log.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="sjoberg:msfp12">8</a>]
</font></td>
<td class="bibtexitem">
Vilhelm Sj&ouml;berg, Chris Casinghino, Ki&nbsp;Yung Ahn, Nathan Collins, Harley
  D.&nbsp;Eades III, Peng Fu, Garrin Kimmell, Tim Sheard, Aaron Stump, and Stephanie
  Weirich.
 <b>Irrelevance, Heterogenous Equality, and Call-by-value Dependent
  Type Systems</b>.
 In <em>Fourth workshop on Mathematically Structured Functional
  Programming (MSFP '12)</em>, pages 112-162, 2012.
[&nbsp;<a href="papers/msfp12prog.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kimmel:plpv">9</a>]
</font></td>
<td class="bibtexitem">
Garrin Kimmell, Aaron Stump, Harley D.&nbsp;Eades III, Peng Fu, Tim Sheard,
  Stephanie Weirich, Chris Casinghino, Vilhelm Sj&ouml;berg, Nathan Collins, and
  Ki&nbsp;Yung Ahn.
 <b>Equational Reasoning about Programs with General Recursion and
  Call-by-value Semantics</b>.
 In <em>Sixth ACM SIGPLAN Workshop Programming Languages meets
  Program Verification (PLPV '12)</em>, pages 15-26, 2012.
[&nbsp;<a href="papers/plpv2012genreccbv.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:lifting">10</a>]
</font></td>
<td class="bibtexitem">
Brent&nbsp;A. Yorgey, Stephanie Weirich, Julien Cretin, Simon Peyton Jones,
  Dimitrios Vytiniotis, and Jos&eacute;&nbsp;Pedro Magalhaes.
 <b>Giving Haskell A Promotion</b>.
 In <em>Seventh ACM SIGPLAN Workshop on. Types in Language Design and
  Implementation (TLDI '12)</em>, pages 53-66, 2012.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/tldi12.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:binders">11</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich, Brent&nbsp;A. Yorgey, and Tim Sheard.
 <b>Binders Unbound</b>.
 In <em>Proceeding of the 16th ACM SIGPLAN International Conference
  on Functional Programming</em>, ICFP '11, pages 333-345, New York, NY, USA,
  2011.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/icfp11.pdf">PDF</a>&nbsp; 
<a href="http://doi.acm.org/10.1145/2034773.2034818">http</a>&nbsp;]
<blockquote><font size="-1">
Keywords: generic programming, haskell, name binding, patterns
</font></blockquote><p>

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:newtypes">12</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich, Dimitrios Vytiniotis, Simon Peyton Jones, and Steve
  Zdancewic.
 <b>Generative Type Abstraction and Type-level Computation</b>.
 In <em>POPL 11: 38th ACM SIGACT-SIGPLAN Symposium on Principles of
  Programming Languages, January 26-28, 2011. Austin, TX, USA.</em>, pages
  227-240, January 2011.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
Modular languages support generative type abstraction,
ensuring that an abstract type is distinct from its
representation, except inside the implementation where the
two are synonymous.  We show that this well-established
feature is in tension with the non-parametric features
of newer type systems, such as indexed type families and GADTs.
In this paper we solve the problem by using kinds to 
distinguish between parametric and non-parametric contexts.
The result is directly applicable to Haskell, which is rapidly
developing support for type-level computation, but the same
issues should arise whenever generativity and non-parametric features
are combined.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="stump:position">13</a>]
</font></td>
<td class="bibtexitem">
Tim Sheard, Aaron Stump, and Stephanie Weirich.
 <b>Language-Based Verification Will Change The World</b>.
 In <em>2010 FSE/SDP Workshop on the Future of Software Engineering
  Research</em>, November 2010.
 Position paper.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/foser10.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="teqt">14</a>]
</font></td>
<td class="bibtexitem">
Aaron Stump, Vilhelm Sj&ouml;berg, and Stephanie Weirich.
 <b>Termination Casts: A Flexible Approach to Termination with
  General Recursion</b>.
 In <em>Workshop on Partiality and Recursion in Interactive Theorem
  Provers</em>, Edinburgh, Scotland, July 2010.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/submitted-PAR-10-Proceedings.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">

This paper proposes a type-and-effect system that
distinguishes terminating terms and total functions from possibly
diverging terms and partial functions, for a lambda calculus with
general recursion and equality types.  The central idea is to include
a primitive type-form &ldquo;Terminates t&rdquo;, expressing that term t is
terminating; and then allow terms t to be coerced from possibly
diverging to total, using a proof of Terminates t.  We call such
coercions <em>termination casts</em>, and show how to implement
terminating recursion using them.  For the meta-theory of the system,
we describe a translation from this system to a logical theory of
termination for general recursive, simply typed functions.  Every
typing judgment of this system is translated to a theorem expressing the
appropriate termination property of the computational part of the
term.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="contracts">15</a>]
</font></td>
<td class="bibtexitem">
Michael Greenberg, Benjamin Pierce, and Stephanie Weirich.
 <b>Contracts Made Manifest</b>.
 In <em>37th ACM SIGACT-SIGPLAN Symposium on Principles of
  Programming Languages (POPL)</em>, pages 353-364, Madrid, Spain, January 2010.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/popl10-greenberg.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">

Since Findler and Felleisen introduced higher-order contracts, many
variants have been proposed.  Broadly, these fall into two groups:
some follow Findler and Felleisen in using latent contracts, purely
dynamic checks that are transparent to the type system; others use
manifest contracts, where refinement types record the most recent
check that has been applied to each value.  These two approaches are
commonly assumed to be equivalent-different ways of implementing the
same idea, one retaining a simple type system, and the other providing
more static information.  Our goal is to formalize and clarify this
folklore understanding.<p>
Our work extends that of Gronski and Flanagan, who defined a latent
calculus lambdac and a manifest calculus lambdah, gave a translation
phi from lambdac to lambdah, and proved that, if a lambdac term
reduces to a constant, then so does its phiimage.  We enrich their
account with a translation psi from lambdah to lambdac and prove an
analogous theorem.<p>
We then generalize the whole framework to dependent contracts, whose
predicates can mention free variables.  This extension is both
pragmatically crucial, supporting a much more interesting range of
contracts, and theoretically challenging.  We define dependent
versions of lambdah and two dialects (&ldquo;lax&rdquo; and &ldquo;picky&rdquo;) of
lambdac, establish type soundness-a substantial result in itself,
for lambdah-and extend phi and psi accordingly.  Surprisingly, the
intuition that the latent and manifest systems are equivalent now
breaks down: the extended translations preserve behavior in one
direction but, in the other, sometimes yield terms that blame more.  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="iseq">16</a>]
</font></td>
<td class="bibtexitem">
Limin Jia, Jianzhou Zhao, Vilhem Sj&ouml;berg, and Stephanie Weirich.
 <b>Dependent types and Program Equivalence</b>.
 In <em>37th ACM SIGACT-SIGPLAN Symposium on Principles of
  Programming Languages (POPL)</em>, pages 275-286, Madrid, Spain, January 2010.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/popl10-lambda-eek.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
The definition of type equivalence is one of the most important design
issues for any typed language. In dependently-typed languages, because
terms appear in types, this definition must rely on a definition of
term equivalence. In that case, decidability of type checking requires
decidability for the term equivalence relation.<p>
Almost all dependently-typed languages require this relation to be
decidable. Some, such as Coq, Epigram or Agda, do so by employing
analyses to force all programs to terminate. Conversely, others, such
as DML, ATS, Omega, or Haskell, allow nonterminating computation, but
do not allow those terms to appear in types. Instead, they identify a
terminating index language and use singleton types to connect indices
to computation. In both cases, decidable type checking comes at a
cost, in terms of complexity and expressiveness.<p>
Conversely, the benefits to be gained by decidable type checking are
modest. Termination analyses allow dependently typed programs to
verify total correctness properties. However, decidable type checking
is not a prerequisite for type safety.  Furthermore, decidability does
not imply tractability. A decidable approximation of program
equivalence may not be useful in practice.<p>
Therefore, we take a different approach: instead of a fixed notion for
term equi valence, we parameterize our type system with an abstract
relation that is not n ecessarily decidable. We then design a novel
set of typing rules that require on ly weak properties of this
abstract relation in the proof of the preservation an d progress
lemmas. This design provides flexibility: we compare valid instantiat
ions of term equivalence which range from beta-equivalence, to
contextual equiva lence, to some exotic equivalences.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="aritygen">17</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich and Chris Casinghino.
 <b>Arity-generic type-generic programming</b>.
 In <em>ACM SIGPLAN Workshop on Programming Languages Meets Program
  Verification (PLPV)</em>, pages 15-26, January 2010.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="bohannon:firescript">18</a>]
</font></td>
<td class="bibtexitem">
Aaron Bohannon, Benjamin&nbsp;C. Pierce, Vilhelm Sj&ouml;berg, Stephanie Weirich, and
  Steve Zdancewic.
 <b>Reactive Noninterference</b>.
 In <em>16th ACM Conference on Computer and Communications Security</em>,
  pages 79-90, November 2009.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/csf09-draft.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
Many programs operate reactively-patiently waiting for user input, running
for a while producing output, and eventually returning to a state where they
are ready to accept another input (or occasionally diverging).  When a
reactive program communicates with multiple parties, we would like to be
sure that it can be given secret information by one without leaking it to
others.<p>
Motivated by web browsers and client-side web applications,
we explore definitions of noninterference for reactive programs and
identify two of special interest-one corresponding to
termination-insensitive noninterference for a simple sequential language,
the other to termination-sensitive noninterference.  We focus on the former
and develop a proof technique for showing that program behaviors are secure
according to this definition.  To demonstrate the viability of the approach,
we define a simple reactive language with an information-flow type system
and apply our proof technique to show that well-typed programs are secure.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:fph">19</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis, Stephanie Weirich, and Simon&nbsp;Peyton Jones.
 <b>FPH: First-class polymorphism for Haskell</b>.
 In <em>ICFP 2008: The 13th ACM SIGPLAN International Conference on
  Functional Programming</em>, pages 295-306, Victoria, BC, Canada, September
  2008.
[&nbsp;<a href="http://www.cis.upenn.edu/~dimitriv/fph">Project</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/icfp08.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
Languages supporting polymorphism typically have ad-hoc restrictions
on where polymorphic types may occur.  Supporting &ldquo;first-class&rdquo; polymorphism,
by lifting those restrictions, is obviously desirable, but it is hard
to achieve this without sacrificing type inference.  We present a new
type system for higher-rank and impredicative polymorphism that improves
on earlier proposals: it is an extension of Damas-Milner;
it relies only on System F types; it has a simple, declarative specification;
it is robust to program transformations; and it enjoys a complete and decidable 
type inference algorithm.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="aydemir:popl-binders">20</a>]
</font></td>
<td class="bibtexitem">
Brian Aydemir, Arthur Chargu&eacute;raud, Benjamin&nbsp;C. Pierce, Randy Pollack, and
  Stephanie Weirich.
 <b>Engineering Formal Metatheory</b>.
 In <em>ACM SIGPLAN-SIGACT Symposium on Principles of
  Programming Languages (POPL)</em>, pages 3-15, January 2008.
[&nbsp;<a href="http://www.chargueraud.org/arthur/research/2007/binders/">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/369">PDF</a>&nbsp;]
<blockquote><font size="-1">
 
Machine-checked proofs of properties of programming languages have become a
critical need, both for increased confidence in large and complex designs
and as a foundation for technologies such as proof-carrying code.  However,
constructing these proofs remains a black art, involving many choices in the
formulation of definitions and theorems that make a huge cumulative
difference in the difficulty of carrying out large formal developments.  The
representation and manipulation of  terms with variable binding is a
key issue.<p>
We propose a novel style for formalizing metatheory, combining
locally nameless representation of terms and
cofinite quantification of free variable names in inductive
definitions of relations on terms (typing, reduction, ...).  The
key technical insight is that our use of cofinite quantification
obviates the need for reasoning about equivariance (the fact that free
names can be renamed in derivations); in particular, the structural 
induction principles of relations defined using cofinite 
quantification are strong enough for metatheoretic reasoning, and 
need not be explicitly strengthened.
Strong inversion principles follow (automatically, in Coq) from the
induction principles.  Although many of the underlying ingredients of
our technique have been used before, their combination here yields a
significant improvement over existing methodology, leading to
developments that are faithful to informal practice, yet require no
external tool support and little infrastructure within the proof
assistant.<p>
We have carried out several large developments in this style using the Coq
proof assistant and have made them publicly available. Our developments
include type soundness for and ML (with references, exceptions,
datatypes, recursion and patterns) and subject reduction for the Calculus of
Constructions. Not only do these developments demonstrate the
comprehensiveness of our approach; they have also been optimized for clarity
and robustness, making them good templates for future extension.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis07a">21</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis and Stephanie Weirich.
 <b>Dependent types: Easy as PIE</b>.
 In Marco&nbsp;T. Moraz&aacute;n and Henrik Nilsson, editors, <em>Draft
  Proceedings of the 8th Symposium on Trends in Functional Programming</em>, pages
  XVII-1-XVII-15. Dept. of Math and Computer Science, Seton Hall
  University, April 2007.
 TR-SHU-CS-2007-04-1.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/tfp07.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:parametricity">22</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis and Stephanie Weirich.
 <b>Free theorems and runtime type representations</b>.
 In <em>Mathematical Foundations of Programming Semantics (MFPS
  XXIII)</em>, pages 357-373, New Orleans, LA, USA, April 2007.
[&nbsp;<a href="http://www.cis.upenn.edu/~dimitriv/parametricity/">Project</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.ps">PS</a>&nbsp;]
<blockquote><font size="-1">

    Reynolds' abstraction theorem, often referred to
  as the parametricity theorem, can be used to derive properties about
  functional programs solely from their types. Unfortunately, in the
  presence of runtime type analysis, the abstraction properties of
  polymorphic programs are no longer valid. However, runtime type
  analysis can be implemented with term-level representations of
  types, as in the  language of Crary et
    al., where case analysis on
  these runtime representations introduces type refinement. In this
  paper, we show that representation-based analysis is consistent with
  type abstraction by extending the abstraction theorem to such a
  language. We also discuss the &ldquo;free theorems&rdquo; that result.  This
  work provides a foundation for the more general problem of extending
  the abstraction theorem to languages with generalized algebraic
  datatypes.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:replib">23</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>RepLib: A library for derivable type classes</b>.
 In <em>Haskell Workshop</em>, pages 1-12, Portland, OR, USA, September
  2006.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/RepLib/">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/362">PDF</a>&nbsp;]
<blockquote><font size="-1">

  Some type class instances can be automatically derived from the
  structure of types. As a result, the Haskell language includes the
  "deriving" mechanism to automatic generates such instances for a
  small number of built-in type classes. In this paper, we present
  RepLib, a GHC library that enables a similar mechanism for arbitrary
  type classes. Users of RepLib can define the relationship between
  the structure of a datatype and the associated instance declaration
  by a normal Haskell functions that pattern-matches a representation
  types. Furthermore, operations defined in this manner are
  extensible-instances for specific types not defined by type
  structure may also be incorporated. Finally, this library also
  supports the definition of operations defined by parameterized
  types.
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="washburn:good-advice">24</a>]
</font></td>
<td class="bibtexitem">
Geoffrey Washburn and Stephanie Weirich.
 <b>Good Advice for Type-directed Programming: Aspect-oriented
  Programming and Extensible Generic Functions</b>.
 In <em>Workshop on Generic Programming (WGP)</em>, pages 33-44,
  Portland, OR, USA, September 2006.
[&nbsp;<a href="http://www.cs.princeton.edu/sip/projects/aspectml/">Project</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/aspect-tdp.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
 
Type-directed programming is an important idiom for software design.
In type-directed programming the behavior of programs is guided by the
type structure of data.  It makes it possible to implement many sorts
of operations, such as serialization, traversals, and queries, only
once and without needing to continually revise their implementation as
new data types are defined.<p>
Type-directed programming is the basis for recent research into
"scrapping" tedious boilerplate code that arises in functional
programming with algebraic data types.  This research has primarily
focused on writing type-directed functions that are closed to
extension. However, L&auml;mmel and Peyton Jones recently developed a
technique for writing openly extensible type-directed functions in
Haskell by making clever use of type classes.  Unfortunately, this
technique has a number of limitations.<p>
We present an alternate approach to writing openly extensible
type-directed functions by using the aspect-oriented programming
features provided by the language AspectML.  Our solution not only
avoids the limitations present in L&auml;mmel and Peyton Jones technique,
but also allows type-directed functions to be extended at any time
with cases for types that were not even known at compile-time.  This
capability is critical to writing programs that make use of dynamic
loading or runtime type generativity.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:boxy">25</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis, Stephanie Weirich, and Simon&nbsp;L. Peyton Jones.
 <b>Boxy type inference for higher-rank types and impredicativity</b>.
 In <em>International Conference on Functional Programming (ICFP)</em>,
  pages 251-262, Portland, OR, USA, September 2006.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/275/">PDF</a>&nbsp;]
<blockquote><font size="-1">
 
               Languages with rich type systems are beginning to
               employ a blend of type inference and type
               checking, so that the type inference engine is
               guided by programmer-supplied type annotations.  In
               this paper we show, for the first time, how to combine
               the virtues of two well-established ideas:
               unification-based inference, and bidirectional
               propagation of type annotations.  The result is a type
               system that conservatively extends Hindley-Milner, and
               yet supports both higher-rank types and
               impredicativity. 
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="pj-vytiniotis:wobbly">26</a>]
</font></td>
<td class="bibtexitem">
Simon&nbsp;L. Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Geoffrey
  Washburn.
 <b>Simple unification-based type inference for GADTs</b>.
 In <em>International Conference on Functional Programming (ICFP)</em>,
  pages 50-61, Portland, OR, USA, September 2006.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/gadt.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
 
               Generalized algebraic data types (GADTs), sometimes known as &ldquo;guarded
               recursive data types&rdquo; or &ldquo;first-class phantom
               types&rdquo;, are a simple but powerful generalization of
               the data types of Haskell and ML.  Recent works have
               given compelling examples of the utility of GADTs,
               although type inference is known to be difficult.  Our
               contribution is to show how to exploit
               programmer-supplied type annotations to make the type
               inference task almost embarrassingly easy.  Our main
               technical innovation is wobbly types, which express in
               a declarative way the uncertainty caused by the
               incremental nature of typical type-inference
               algorithms. 
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="aydemir:nominal-coq">27</a>]
</font></td>
<td class="bibtexitem">
Brian Aydemir, Aaron Bohannon, and Stephanie Weirich.
 <b>Nominal Reasoning Techniques in Coq</b>.
 In <em>International Workshop on Logical Frameworks and
  Meta-Languages:Theory and Practice (LFMTP)</em>, pages 60-69, Seattle, WA, USA,
  August 2006.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/">Project</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/lfmtp06.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">

  We explore an axiomatized nominal approach to variable binding in Coq,
  using an untyped lambda-calculus as our test case.  In our nominal
  approach, alpha-equality of lambda terms coincides with Coq's built-in
  equality.  Our axiomatization includes a nominal induction principle and
  functions for calculating free variables and substitution.  These axioms
  are collected in a module signature and proved sound
  using locally nameless terms as the underlying
  representation.  Our experiences so far suggests that it is feasible to
  work from such axiomatized theories in Coq and that the nominal style of
  variable binding corresponds closely with paper proofs.  We are currently
  working on proving the soundness of a primitive recursion combinator
  and developing a method of generating these axioms and their proof of
  soundness from a grammar describing the syntax of terms and binding.     
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="pierce:position">28</a>]
</font></td>
<td class="bibtexitem">
Benjamin&nbsp;C. Pierce, Peter Sewell, Stephanie Weirich, and Steve Zdancewic.
 <b>It is Time to Mechanize Programming Language Metatheory</b>.
 In <em>Verified Software: Theories, Tools, Experiments (VS:TTE)</em>,
  Z&uuml;rich, Switzerland, October 2005.
 5 pages.
[&nbsp;<a href="http://fling-l.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=The_POPLmark_Challenge">Project</a>&nbsp; 
<a href="http://vstte.ethz.ch/Files/pierce-sewell-weirich-zdancewic.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
<p>
How close are we to a world in which mechanically verified software is
commonplace? A world in which theorem proving technology is used
routinely by both software developers and programming
language researchers alike? One crucial step towards achieving these
goals is mechanized reasoning about language metatheory. The time has
come to bring together the theorem proving and programming language
communities to address this problem. We have proposed the POPLMark
challenge as a concrete set of benchmarks intended both for measuring
progress in this area and for stimulating discussion and
collaboration. Our goal is to push the boundaries of existing
technology to the point where we can achieve mechanized metatheory for
the masses.
 
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="dantas:polyaml">29</a>]
</font></td>
<td class="bibtexitem">
Daniel&nbsp;S. Dantas, David Walker, Geoffrey Washburn, and Stephanie Weirich.
 <b>PolyAML: A polymorphic aspect-oriented functional programmming
  language</b>.
 In <em>ACM SIGPLAN International Conference on Functional
  Programming (ICFP)</em>, pages 306-319, Tallinn, Estonia, September 2005.
[&nbsp;<a href="http://www.cs.princeton.edu/sip/projects/aspectml/">Project</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/poly/poly-aspect.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/poly/poly-aspect.ps">PS</a>&nbsp;]
<blockquote><font size="-1">

This paper defines PolyAML, a typed functional and aspect-oriented
programming language.  The main contribution of PolyAML is in the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  In order to support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.<p>
We give our language operational meaning via a type-directed
translation into an expressive type-safe intermediate language.  Many
complexities of the source language are eliminated in this
translation, leading to a modular specification of its semantics.  One
of the novelties of the intermediate language is the definition of
polymorphic labels for marking control-flow points.  These labels are
organized in a tree structure such that a parent in the tree serves as
a representative for the collection of all its children.  Type safety
requires that the type of each child is a generic instance of the type
of the polymorphic parent.  Similarly, when a set of labels is
assembled as a pointcut, the type of each label is an instance of the
type of the pointcut.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="mmm">30</a>]
</font></td>
<td class="bibtexitem">
Brian&nbsp;E. Aydemir, Aaron Bohannon, Matthew Fairbairn, J.&nbsp;Nathan Foster,
  Benjamin&nbsp;C. Pierce, Peter Sewell, Dimitrios Vytiniotis, Geoffrey Washburn,
  Stephanie Weirich, and Steve Zdancewic.
 <b>Mechanized Metatheory for the Masses: The POPLmark Challenge</b>.
 In <em>The 18th International Conference on Theorem Proving in
  Higher Order Logics (TPHOLs)</em>, pages 50-65, Oxford, UK, August 2005.
[&nbsp;<a href="http://alliance.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=The_POPLmark_Challenge">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/235/">PDF</a>&nbsp; 
<a href="http://www.cis.upenn.edu/proj/plclub/mmm/poplmark/poplmark.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
How close are we to a world where every paper on
programming languages is accompanied by an electronic appendix with
machine-checked proofs?<p>
We propose a concrete set of benchmarks for measuring progress in this
area.  Based on the metatheory of System F-sub, a typed
lambda-calculus with second-order polymorphism, subtyping, and
records, these benchmarks embody many aspects of programming languages
that are challenging to formalize: variable binding at both the term
and type levels, syntactic forms with variable numbers of components
(including binders), and proofs demanding complex induction
principles.  We hope that these benchmarks will help clarify the
current state of the art, provide a basis for comparing competing
technologies, and motivate further research.  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="washburn:seckinds">31</a>]
</font></td>
<td class="bibtexitem">
Geoffrey Washburn and Stephanie Weirich.
 <b>Generalizing Parametricity Using Information Flow</b>.
 In <em>Twentieth Annual IEEE Symposium on. Logic in Computer Science
  (LICS 2005)</em>, pages 62-71, Chicago, IL, USA, June 2005.
[&nbsp;<a href="http://www.seas.upenn.edu/%7Esweirich/tdj/tdj.htm">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/220/">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/seckinds/lics2005.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
Run-time type analysis allows programmers to easily and
concisely define many operations based upon type structure, such as
serialization, iterators, and structural equality.  However, when
types can be inspected at run time, nothing is secret.  A module
writer cannot use type abstraction to hide implementation details from
clients: those clients can use type analysis to determine the
structure of these supposedly &ldquo;abstract&rdquo; data types.  Furthermore,
access control mechanisms do not help in isolating the implementation
of abstract datatypes from their clients.  Buggy or malicious
authorized modules may simply leak type information to unauthorized
clients, so module implementors cannot reliably tell which parts of a
program rely on their type definitions and which parts do not.<p>
Currently, module implementors rely on parametric polymorphism to
provide guarantees about the use of their abstract datatypes.
Standard type parametricity does not hold for a language with run-time
type analysis, but in this paper we show how to generalize the
statement of parametricity so that it does hold in the presence of
type analysis and still encompasses the integrity and confidentiality
policies that are normally derived from parametricity.  The key is to
augment the type system with annotations about information flow.
Because the type system tracks the flow of dynamic type information,
the implementor of an abstract data type can easily see what parts of
the program depend on the implementation of a given type.  

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:itaname">32</a>]
</font></td>
<td class="bibtexitem">
Dimtrios Vytiniotis, Geoffrey Washburn, and Stephanie Weirich.
 <b>An Open and Shut Typecase</b>.
 In <em>ACM SIGPLAN Workshop on Types in Language Design and
  Implementation</em>, pages 13-24, Long Beach, CA, USA, January 2005.
[&nbsp;<a href="http://www.cis.upenn.edu/~dimitriv/itaname/itaname.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
Two different ways of defining ad-hoc polymorphic operations commonly
occur in programming languages. With the first form polymorphic
operations are defined inductively on the structure of types while
with the second form polymorphic operations are defined for specific
sets of types.<p>
In intensional type analysis operations are defined by induction on
the structure of types. Therefore no new cases are necessary for
user-defined types, because these types are equivalent to their
underlying structure.  However, intensional type analysis is
&ldquo;closed&rdquo; to extension, as the behavior of the operations cannot be
differentiated for the new types, thus destroying the distinctions
that these types are designed to express.<p>
Haskell type classes on the other hand define polymorphic operations
for sets of types. Operations defined by class instances are
considered &ldquo;open&rdquo;-the programmer can add instances for new types
without modifying existing code. However, the operations must be
extended with specialized code for each new type, and it may be
tedious or even impossible to add extensions that apply to a large
universe of new types.<p>
Both approaches have their benefits, so it is important to let
programmers decide which is most appropriate for their needs. In this
paper, we define a language that supports both forms of ad-hoc
polymorphism, using the same basic constructs.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:tdj">33</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich and Liang Huang.
 <b>A Design for Type-Directed Java</b>.
 In Viviana Bono, editor, <em>Workshop on Object-Oriented
  Developments (WOOD)</em>, ENTCS, pages 117-136, 2004.
[&nbsp;<a href="http://www.seas.upenn.edu/%7Esweirich/tdj/tdj.htm">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/275/">PDF</a>&nbsp; 
<a href="http://www.cis.upenn.edu/~lhuang3/pubs/tdj-short.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
   
  Type-directed programming is an important and widely used
  paradigm in the design of software. With this form of programming,
  an application may analyze type information to determine its
  behavior. By analyzing the structure of data, many operations, such
  as serialization, cloning, adaptors and iterators may be defined
  once, for all types of data. That way, as the program evolves, these
  operations need not be updated-they will automatically adapt to
  new data forms.  Otherwise, each of these operations must be
  individually redefined for each type of data, forcing programmers to
  revisit the same program logic many times during a program's
  lifetime.<p>
  The Java language supports type directed programming with the
  instanceof operator and the Java Reflection API.  These
  mechanisms allow Java programs to depend on the name and structure
  of the run-time classes of objects.  However, the Java mechanisms
  for type-directed programming are difficult to use. They also do not
  integrate well with generics, an important new feature of the Java
  language.<p>
  In this paper, we describe the design of several expressive new
  mechanisms for type-directed programming in Java, and show that
  these mechanisms are sound when included in a language similar to
  Featherweight Java. Basically, these new mechanisms pattern-match
  the name and structure of the type parameters of generic code,
  instead of the run-time classes of objects.  Therefore, they
  naturally integrate with generics and provide strong guarantees
  about program correctness. As these mechanisms are based on pattern
  matching, they naturally and succinctly express many operations that
  depend on type information. Finally, they provide programmers with
  some degree of protection for their abstractions. Whereas
  instanceof and reflection can determine the exact run-time type
  of an object, our mechanisms allow any supertype to be supplied for
  analysis, hiding its precise structure.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="washburn:itabox">34</a>]
</font></td>
<td class="bibtexitem">
Geoffrey Washburn and Stephanie Weirich.
 <b>Boxes Go Bananas: Encoding Higher-order Abstract Syntax with
  Parametric Polymorphism</b>.
 In <em>ACM SIGPLAN International Conference on Functional
  Programming (ICFP)</em>, pages 249-262, Uppsala, Sweden, August 2003.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
Higher-order abstract syntax is a simple technique for
implementing languages with functional programming.  Object variables
and binders are implemented by variables and binders in the host
language.  By using this technique, one can avoid implementing common
and tricky routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.<p>
In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive &ldquo;fusion laws&rdquo; that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Schuermann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System F-omega.
This encoding can serve as a starting point for reasoning about
higher-order structures in polymorphic languages.  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:hota">35</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Higher-Order Intensional Type Analysis</b>.
 In Daniel&nbsp;Le M&eacute;tayer, editor, <em>11th European Symposium on
  Programming (ESOP)</em>, pages 98-114, Grenoble, France, April 2002.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/hota/hota.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/hota/hota.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
Intensional type analysis provides the ability to
     analyze abstracted types at run time. In this paper, we extend
     that ability to higher-order and kind-polymorphic type
     constructors. The resulting language is elegant and expressive:
     we show through examples how it extends the repertoire of
     polytypic functions that may be defined.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich01">36</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Encoding Intensional Type Analysis</b>.
 In D.&nbsp;Sands, editor, <em>10th European Symposium on Programming
  (ESOP)</em>, pages 92-106, Genova, Italy, April 2001.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.ps">PS</a>&nbsp; 
<a href="http://link.springer.de/link/service/series/0558/tocs/t2028.htm">http</a>&nbsp;]
<blockquote><font size="-1">
Languages for intensional type analysis permit ad-hoc
     polymorphism, or run-time analysis of types. However, such
     languages require complex, specialized constructs to support this
     operation, which hinder optimization and complicate the
     meta-theory of these languages. In this paper, we observe that
     such specialized operators need not be intrinsic to the language,
     and in fact, their operation may be simulated through standard
     encodings of iteration in the polymorphic lambda
     calculus. Therefore, we may more easily add intensional analysis
     operators to complicated languages via a translation semantics,
     instead of through language extension.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich00">37</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Type-Safe Cast: Functional Pearl</b>.
 In <em>Proceedings of the fifth ACM SIGPLAN International
  Conference on Functional Programming (ICFP)</em>, pages 58-67, Montreal, Canada,
  September 2000.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/cast/cast.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/cast/cast.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
In a language with non-parametric or ad-hoc
    polymorphism, it is possible to determine the identity of a type
    variable at run time.  With this facility, we can write a function
    to convert a term from one abstract type to another, if the two
    hidden types are identical.  However, the naive implementation of
    this function requires that the term be destructed and rebuilt. In
    this paper, we show how to eliminate this overhead using
    higher-order type abstraction. We demonstrate this solution in two
    frameworks for ad-hoc polymorphism: intensional type analysis and
    type classes.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="crary00">38</a>]
</font></td>
<td class="bibtexitem">
Karl Crary and Stephanie Weirich.
 <b>Resource Bound Certification</b>.
 In <em>The Twenty-Seventh ACM SIGPLAN-SIGACT Symposium on
  Principles of Programming Languages (POPL)</em>, pages 184-198, Boston, MA, USA,
  January 2000.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/res/res.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/res/res.ps.gz">PS</a>&nbsp;]
<blockquote><font size="-1">
Various code certification systems allow the
    certification and static verification of a variety of important
    safety properties such as memory safety and control-flow
    safety. These systems provide valuable tools for verifying that
    untrusted and potentially malicious code is safe before execution.
    However, one important safety property that is not usually
    included is that programs adhere to specific bounds on resource
    consumption, such as running time.<p>
    We present a decidable type system capable of specifying and
    certifying bounds on resource consumption. Our system makes two
    advances over previous resource bound certification systems, both
    of which are necessary for a practical system: we allow the
    execution time of programs and their subroutines to vary,
    depending on their arguments, and we provide a fully automatic
    compiler generating certified executables from source-level
    programs. The principal device in our approach is a strategy for
    simulating dependent types using sum and inductive kinds. 
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="crary:lx">39</a>]
</font></td>
<td class="bibtexitem">
Karl Crary and Stephanie Weirich.
 <b>Flexible Type Analysis</b>.
 In <em>Proceedings of the fourth ACM SIGPLAN International
  Conference on Functional Programming (ICFP)</em>, pages 233-248, Paris, France,
  September 1999.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.ps.gz">PS</a>&nbsp;]
<blockquote><font size="-1">
Run-time type dispatch enables a variety of advanced
     optimization techniques for polymorphic languages, including
     tag-free garbage collection, unboxed function arguments, and
     flattened data structures.  However, modern type-preserving
     compilers transform types between stages of compilation, making
     type dispatch prohibitively complex at low levels of typed
     compilation. It is crucial therefore for type analysis at these
     low levels to refer to the types of previous
     stages. Unfortunately, no current intermediate language supports
     this facility.<p>
     To fill this gap, we present the language LX, which provides a
     rich language of type constructors supporting type analysis
     (possibly of previous-stage types) as a programming idiom. This
     language is quite flexible, supporting a variety of other
     applications such as analysis of quantified types, analysis with
     incomplete type information, and type classes. We also show that
     LX is compatible with a type-erasure semantics.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="morrisett:talx86">40</a>]
</font></td>
<td class="bibtexitem">
Greg Morrisett, Karl Crary, Neal Glew, Dan Grossman, Richard Samuels, Frederick
  Smith, David Walker, Stephanie Weirich, and Steve Zdancewic.
 <b>TALx86: A Realistic Typed Assembly Language</b>.
 In <em>Second ACM SIGPLAN Workshop on Compiler Support for
  System Software</em>, pages 25-35, Atlanta, GA, USA, May 1999.
 Published as INRIA research report number 0228, March 1999.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
The goal of typed assembly language (TAL) is to provide
     a low-level, statically typed target language that is better
     suited than Java bytecodes for supporting a wide variety of
     source languages and a number of important optimizations. In
     previous work, we formalized idealized versions of TAL and proved
     important safety properties about them. In this paper, we present
     our progress in defining and implementing a realistic typed
     assembly language called TALx86. The TALx86 instructions comprise
     a relatively complete fragment of the Intel IA32 (32-bit 80x86
     flat model) assembly language and are thus executable on
     processors such as the Intel Pentium. The type system for the
     language incorporates a number of advanced features necessary for
     safely compiling large programs to good code.<p>
     To motivate the design of the type system, we demonstrate how
     various high-level language features are compiled to TALx86. For
     this purpose, we present a type-safe C-like language called
     Popcorn.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="crary:intensional">41</a>]
</font></td>
<td class="bibtexitem">
Karl Crary, Stephanie Weirich, and Greg Morrisett.
 <b>Intensional Polymorphism in Type Erasure Semantics</b>.
 In <em>Proceedings of the third ACM SIGPLAN International
  Conference on Functional Programming (ICFP)</em>, pages 301-313, Baltimore, MD,
  USA, September 1998.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
 Intensional polymorphism, the ability to dispatch to
  different routines based on types at run time, enables a variety of
  advanced implementation techniques for polymorphic languages,
  including tag-free garbage collection, unboxed function arguments,
  polymorphic marshalling, and flattened data structures. To date,
  languages that support intensional polymorphism have required a
  type-passing (as opposed to type-erasure) interpretation where types
  are constructed and passed to polymorphic functions at run
  time. Unfortunately, type-passing suffers from a number of
  drawbacks; it requires duplication of constructs at the term and
  type levels, it prevents abstraction, and it severely complicates
  polymorphic closure conversion. We present a type-theoretic
  framework that supports intensional polymorphism, but avoids many of
  the disadvantages of type passing. In our approach, run-time type
  information is represented by ordinary terms. This avoids the
  duplication problem, allows us to recover abstraction, and avoids
  complications with closure conversion. In addition, our type system
  provides another improvement in expressiveness; it allows unknown
  types to be refined in place thereby avoiding certain
  beta-expansions required by other frameworks.  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="flanagan96">42</a>]
</font></td>
<td class="bibtexitem">
Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Stephanie Weirich, and
  Matthias Felleisen.
 <b>Catching Bugs in the Web of Program Invariants</b>.
 In <em>ACM SIGPLAN Conference on Programming Language Design and
  Implementation (PLDI)</em>, pages 23-32, 1996.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
MrSpidey is a user-friendly, interactive static
     debugger for Scheme. A static debugger supplements the standard
     debugger by analyzing the program and pinpointing those program
     operations tha may cause run-time errors suce as dereferencing
     the null pointer or applying non-functions. The program analysis
     of MrSpidey computes value set descriptions for each term in the
     program and constructs a value flow graph connecting the set
     descriptions. Using the set descriptions, MrSpidey can identify
     and highlight potentially erroneous program operations, whose
     cause the programmer can the explore by selectively exposing
     portions of the value flow graph.
</font></blockquote><p>
<p>
</font></td>
</tr>
</table><hr>

</td></tr>
<tr><td width=100% class=lightaqua valign=middle align=left>
<font size=4>Journal Articles</font>

<!-- This document was automatically generated with bibtex2html 1.96
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s boldtitle -nodoc -d -r -both -nobibsource -nf ps PS -nf pdf PDF -nf projecturl Project journal.bib  -->


<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="pii13preface">1</a>]
</font></td>
<td class="bibtexitem">
Zhengjiang Hu, Shin-Cheng Mu, and Stephanie Weirich.
 <b>Advanced programming techniques for construction of robust,
  generic and evolutionary programs</b>.
 <em>Progress in Informatics</em>, (10):1-2, March 2013.
[&nbsp;<a href="http://www.nii.ac.jp/pi/">http</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="pii13kimmel">2</a>]
</font></td>
<td class="bibtexitem">
Garrin Kimmel, Aaron Stump, Harley&nbsp;D. Eades, Peng Fu, Tim Sheard, Stephanie
  Weirich, Chris Casinghino, Vilhelm Sj&ouml;berg, Nathin Collins, and Ki&nbsp;Yunh
  Anh.
 <b>Equational reasoning about programs with general recursion and
  call-by-value semantics</b>.
 <em>Progress in Informatics</em>, (10):19-48, March 2013.
[&nbsp;<a href="http://www.nii.ac.jp/pi/">http</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="greenberg:jfp">3</a>]
</font></td>
<td class="bibtexitem">
Michael Greenberg, Benjamin&nbsp;C. Pierce, and Stephanie Weirich.
 <b>Contracts made manifest</b>.
 <em>Journal of Functional Programming</em>, 22(3):225-274, May 2012.

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="plmw12">4</a>]
</font></td>
<td class="bibtexitem">
Kathleen Fisher, Ronald Garcia, and Stephanie Weirich.
 <b>Nourishing the future of the field: the programming language
  mentoring workshop 2012</b>.
 <em>SIGPLAN Not.</em>, 47(4a):14-15, April 2012.
[&nbsp;<a href="http://dx.doi.org/10.1145/2442776.2448985">DOI</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DBLP:journals/jar/PierceW12">5</a>]
</font></td>
<td class="bibtexitem">
Benjamin&nbsp;C. Pierce and Stephanie Weirich.
 <b>Preface</b>.
 <em>J. Autom. Reasoning</em>, 49(3):301-302, 2012.

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DBLP:journals/jfp/AcarCW12">6</a>]
</font></td>
<td class="bibtexitem">
Umut&nbsp;A. Acar, James Cheney, and Stephanie Weirich.
 <b>Editorial - Special issue dedicated to ICFP 2010</b>.
 <em>J. Funct. Program.</em>, 22(4-5):379-381, 2012.

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:romega">7</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis and Stephanie Weirich.
 <b>Parametricity, Type Equality and Higher-order Polymorphism</b>.
 <em>Journal of Functional Programming</em>, 20(2):175-210, March 2010.
[&nbsp;<a href="http://www.cis.upenn.edu/~sweirich/papers/gparam-jfp2.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">

  Propositions that express type equality are a frequent ingredient of
  modern functional programming-they can encode generic
  functions, dynamic types, and GADTs. Via the Curry-Howard
  correspondence, these propositions are ordinary types
  inhabited by proof terms, computed using runtime type
  representations. In this paper we show that two examples of type
  equality propositions actually do reflect type equality; they are
  only inhabited when their arguments are equal and their proofs are
  unique (up to contextual equivalence.)  We show this result in the
  context of a strongly normalizing language with higher-order
  polymorphism and primitive recursion over runtime type
  representations by proving Reynolds's abstraction theorem. We then
  use this theorem to derive &ldquo;free&rdquo; theorems about equality types.

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="dantas:aspectml-journal">8</a>]
</font></td>
<td class="bibtexitem">
Daniel&nbsp;S. Dantas, David Walker, Geoffrey Washburn, and Stephanie Weirich.
 <b>AspectML: A Polymorphic Aspect-oriented Functional Programming
  Language</b>.
 <em>ACM Transactions on Programming Languages</em>, 30(3):1-60, May
  2008.
[&nbsp;<a href="http://doi.acm.org/10.1145/1353445.1353448">DOI</a>&nbsp; 
<a href="http://www.cs.princeton.edu/sip/projects/aspectml/">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/379">PDF</a>&nbsp;]
<blockquote><font size="-1">

This paper defines Aspectml, a typed functional, aspect-oriented
programming language. The main contribution of Aspectml is the
seamless integration of polymorphism, run-time type analysis
and aspect-oriented programming language features. In particular,
Aspectml allows programmers to define type-safe polymorphic advice
using pointcuts constructed from a collection of polymorphic join
points. Aspectml also comes equipped with a type inference algorithm
that conservatively extends Hindley-Milner type inference. To support
first-class polymorphic point-cut designators, a crucial feature for
developing aspect-oriented profiling or logging libraries, the
algorithm blends the conventional Hindley-Milner type inference
algorithm with a simple form of local type inference.<p>
We give our language operational meaning via a type-directed
translation into an expressive type-safe intermediate language. Many
complexities of the source language are eliminated in this
translation, leading to a modular specification of its semantics. One
of the novelties of the intermediate language is the definition of
polymorphic labels for marking control-flow points. These labels are
organized in a tree structure such that a parent in the tree serves as
a representative for all of its children. Type safety requires that
the type of each child is less polymorphic than its parent
type. Similarly, when a set of labels is assembled as a pointcut, the
type of each label is an instance of the type of the pointcut.
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="washburn:bgb-journal">9</a>]
</font></td>
<td class="bibtexitem">
Geoffrey Washburn and Stephanie Weirich.
 <b>Boxes Go Bananas: Encoding Higher-order Abstract Syntax with
  Parametric Polymorphism</b>.
 <em>Journal of Functional Programming</em>, 18(1):87-140, January 2008.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/bgb-jfp.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">

Higher-order abstract syntax is a simple technique for implementing
languages with functional programming. Object variables and binders
are implemented by variables and binders in the host language. By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution. However, despite the advantages this technique provides,
it is not commonly used because it is difficult to write sound
elimination forms (such as folds or catamorphisms) for
higherorder abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric. <p>
In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals. From
this implementation, we derive fusion laws that functional
programmers may use to reason about the iteration operator. Finally,
we show how this use of parametric polymorphism corresponds to the
Sch&uuml;rmann, Despeyroux and Pfenning method of enforcing parametricity
through modal types. We do so by using this library to give a sound
and complete encoding of their calculus into System F-omega. This
encoding can serve as a starting point for reasoning about
higher-order structures in polymorphic languages.
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="peyton-jones:practical">10</a>]
</font></td>
<td class="bibtexitem">
Simon&nbsp;L. Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Mark
  Shields.
 <b>Practical type inference for arbitrary-rank types</b>.
 <em>Journal of Functional Programming</em>, 17(1):1-82, January 2007.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_papers/315/">PDF</a>&nbsp;]
<blockquote><font size="-1">

Haskell's popularity has driven the need for ever more expressive type
system features, most of which threaten the decidability and
practicality of Damas-Milner type inference. One such feature is the
ability to write functions with higher-rank types - that is,
functions that take polymorphic functions as their arguments.<p>
Complete type inference is known to be undecidable for higher-rank
(impredicative) type systems, but in practice programmers are more
than willing to add type annotations to guide the type inference
engine, and to document their code. However, the choice of just what
annotations are required, and what changes are required in the type
system and its inference algorithm, has been an ongoing topic of
research.<p>
We take as our starting point a lambda-calculus proposed by Odersky
and Laufer. Their system supports arbitrary-rank polymorphism through
the exploitation of type annotations on lambda-bound arguments and
arbitrary sub-terms. Though elegant, and more convenient than some
other proposals, Odersky and Laufer's system requires many
annotations. We show how to use local type inference (invented by
Pierce and Turner) to greatly reduce the annotation burden, to the
point where higher-rank types become eminently usable.<p>
Higher-rank types have a very modest impact on type inference. We
substantiate this claim in a very concrete way, by presenting a
complete type-inference engine, written in Haskell, for a traditional
Damas-Milner type system, and then showing how to extend it for
higher-rank types. We write the type-inference engine using a monadic
framework: it turns out to be a particularly compelling example of
monads in action.<p>
The paper is long, but is strongly tutorial in style.
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:erasure">11</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Type-Safe Run-time Polytypic Programming</b>.
 <em>Journal of Functional Programming</em>, 16(10):681-710, November
  2006.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/erasure/erasure-jfp.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
   
  Polytypic programming is a way of defining type-indexed
  operations, such as map, fold and zip, based on type information.
  Run-time polytypic programming allows that type information to
  be dynamically computed-this support is essential in modern
  programming languages that support separate compilation, first-class
  type abstraction, or polymorphic recursion.
  
  However, in previous work we defined run-time polytypic programming
  with a type-passing semantics. Although it is natural to define
  polytypic programs as operating over first-class types, such a
  semantics suffers from a number of drawbacks. This paper describes
  how to recast that work in a type-erasure semantics, where terms
  represent type information in a safe manner.  The resulting language
  is simple and easy to implement-we present a prototype
  implementation of the necessary machinery as a small Haskell
  library.                                                           
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:cast-journal">12</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Type-Safe Cast</b>.
 <em>Journal of Functional Programming</em>, 14(6):681-695, November
  2004.
[&nbsp;<a href="http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&REQSESS=1422511&118000REQEVENT=&REQINT1=254715&REQAUTH=0">PDF</a>&nbsp;]
<blockquote><font size="-1">
   Comparing two types for equality is an essential ingredient for an
  implementation of dynamic types. Once equality has been established,
  it is safe to cast a value from one type to another. In a language
  with run-time type analysis, implementing such a procedure is fairly
  straightforward.  Unfortunately, this naive implementation destructs
  and rebuilds the argument while iterating over its type structure.
  However, by using higher-order polymorphism, a casting function can
  treat its argument parametrically. We demonstrate this solution in
  two frameworks for ad-hoc polymorphism: intensional type analysis
  and Haskell type classes.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="crary:intensional-journal">13</a>]
</font></td>
<td class="bibtexitem">
Karl Crary, Stephanie Weirich, and Greg Morrisett.
 <b>Intensional Polymorphism in Type Erasure Semantics</b>.
 <em>Journal of Functional Programming</em>, 12(6):567-600, November
  2002.
[&nbsp;<a href="http://journals.cambridge.org/action/displayFulltext?type=1&fid=129250&jid=JFP&volumeId=12&issueId=06&aid=129249">PDF</a>&nbsp;]
<blockquote><font size="-1">
Intensional polymorphism, the ability to dispatch to
     different routines based on types at run time, enables a variety
     of advanced implementation techniques for polymorphic languages,
     including tag-free garbage collection, unboxed function
     arguments, polymorphic marshalling, and flattened data
     structures. To date, languages that support intensional
     polymorphism have required a type-passing (as opposed to
     type-erasure) interpretation where types are constructed and
     passed to polymorphic functions at run time. Unfortunately,
     type-passing suffers from a number of drawbacks; it requires
     duplication of constructs at the term and type levels, it
     prevents abstraction, and it severely complicates polymorphic
     closure conversion.  We present a type-theoretic framework that
     supports intensional polymorphism, but avoids many of the
     disadvantages of type passing. In our approach, run-time type
     information is represented by ordinary terms. This avoids the
     duplication problem, allows us to recover abstraction, and avoids
     complications with closure conversion. In addition, our type
     system provides another improvement in expressiveness; it allows
     unknown types to be refined in place thereby avoiding certain
     beta-expansions required by other frameworks.
</font></blockquote><p>
<p>
</font></td>
</tr>
</table><hr>

</td></tr>
<tr><td width=100% class=lightaqua valign=middle align=left>
<font size=4>Journal Articles</font>

<!-- This document was automatically generated with bibtex2html 1.96
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s boldtitle -nodoc -d -r -both -nobibsource -nf ps PS -nf pdf PDF -nf projecturl Project chapters.bib  -->


<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:handbook">1</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Type Systems</b>.
 In Teofilo Gonzalez, editor, <em>Computing Handbook Set-Computer
  Science (I)</em>, pages 69-1-69-39. CRC Press, third edition, 2014.
 Forthcoming.

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:aritygen-journal">2</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich and Chris Casinghino.
 <b>Generic Programming with Dependent Types</b>.
 In Jeremy Gibbons, editor, <em>Generic and Indexed Programming</em>,
  number 7470 in Lecture Notes in Computer Science, pages 217-258.
  Springer-Verlag Berlin Heidelberg, 2012.
[&nbsp;<a href="http://www.cis.upenn.edu/~sweirich/papers/ssgip-journal.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="hicks00">3</a>]
</font></td>
<td class="bibtexitem">
Michael Hicks, Stephanie Weirich, and Karl Crary.
 <b>Safe and Flexible Dynamic Linking of Native Code</b>.
 In R.&nbsp;Harper, editor, <em>Types in Compilation: Third International
  Workshop, TIC 2000; Montreal, Canada, September 21, 2000; Revised Selected
  Papers</em>, volume 2071 of <em>Lecture Notes in Computer Science</em>, pages
  147-176. Springer, 2001.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.ps.gz">PS</a>&nbsp; 
<a href="http://link.springer.de/link/service/series/0558/tocs/t2071.htm">http</a>&nbsp;]
<blockquote><font size="-1">
We present the design and implementation of the first
     complete framework for flexible and safe dynamic linking of
     native code. Our approach extends Typed Assembly Language with a
     primitive for loading and typechecking code, which is flexible
     enough to support a variety of linking strategies, but simple
     enough that it does not significantly expand the trusted
     computing base. Using this primitive, along with the ability to
     compute with types, we show that we can program many existing
     dynamic linking approaches. As a concrete demonstration, we have
     used our framework to implement dynamic linking for a type-safe
     dialect of C, closely modeled after the standard linking facility
     for Unix C programs. Aside from the unavoidable cost of
     verification, our implementation performs comparably with the
     standard, untyped approach.
</font></blockquote><p>
<p>
</font></td>
</tr>
</table><hr>

</td></tr>
<tr><td width=100% class=lightaqua valign=middle align=left>
<font size=4>Thesis</font>

<!-- This document was automatically generated with bibtex2html 1.96
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s boldtitle -nodoc -d -r -both -nobibsource -nf ps PS -nf pdf PDF thesis.bib  -->


<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:phd">1</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich.
 <b>Programming With Types</b>.
 PhD thesis, Cornell University, August 2002.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
Run-time type analysis is an increasingly important linguistic
     mechanism in modern programming languages. Language runtime
     systems use it to implement services such as accurate garbage
     collection, serialization, cloning and structural
     equality. Component frameworks rely on it to provide reflection
     mechanisms so they may discover and interact with program
     interfaces dynamically. Run-time type analysis is also crucial
     for large, distributed systems that must be dynamically extended,
     because it allows those systems to check program invariants when
     new code and new forms of data are added. Finally, many generic
     user-level algorithms for iteration, pattern matching, and
     unification can be defined through type analysis mechanisms.<p>
     However, existing frameworks for run-time type analysis were
     designed for simple type systems. They do not scale well to the
     sophisticated type systems of modern and next-generation
     programming languages that include complex constructs such as
     first-class abstract types, recursive types, objects, and type
     parameterization. In addition, facilities to support type
     analysis often require complicated language semantics that allow
     little freedom in their implementation.  This dissertation
     investigates the foundations of run-time type analysis in the
     context of statically-typed, polymorphic programming languages.
     Its goal is to show how such a language may support
     type-analyzing operations in a way that balances expressiveness,
     safety and simplicity.
</font></blockquote><p>
<p>
</font></td>
</tr>
</table><hr>

</td></tr>
<tr><td width=100% class=lightaqua valign=middle align=left>
<font size=4>Technical Reports</font>

<!-- This document was automatically generated with bibtex2html 1.96
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s boldtitle -nodoc -d -r -both -nobibsource -nf ps PS -nf pdf PDF -nf projecturl Project techreport.bib  -->


<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="breitner:safe-coercions-extended">1</a>]
</font></td>
<td class="bibtexitem">
Joachim Breitner, Richard&nbsp;A. Eisenberg, Simon Peyton Jones, and Stephanie
  Weirich.
 <b>Safe Zero-cost Coercions for Haskell (Extended Version)</b>.
 Technical Report MS-CIS-14-07, Univ. of Pennsylvania, 2014.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/coercible-extended.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="eisenberg:closed-tf-extended">2</a>]
</font></td>
<td class="bibtexitem">
Richard&nbsp;A. Eisenberg, Dimitrios Vytiniotis, Simon Peyton Jones, and Stephanie
  Weirich.
 <b>Closed type families with overlapping equations (Extended
  version)</b>.
 Technical Report MS-CIS-13-10, University of Pennsylvania, 2013.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms-extended.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="casinghino:combining-proofs-extended">3</a>]
</font></td>
<td class="bibtexitem">
Chris Casinghino, Vilhelm Sj&ouml;berg, and Stephanie Weirich.
 <b>Combining Proofs and Programs in a Dependently Typed Language
  (With Technical Appendix)</b>.
 Technical Report MS-CIS-13-08, University of Pennsylvania, 2013.

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="weirich:newtypes-long">4</a>]
</font></td>
<td class="bibtexitem">
Stephanie Weirich, Dimitrios Vytiniotis, Simon Peyton Jones, and Steve
  Zdancewic.
 <b>Generative Type Abstraction and Type-level Computation (Extended
  Version)</b>.
 Technical report, November 2010.
[&nbsp;<a href="http://www.cis.upenn.edu/~sweirich/papers/newtypes.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">
Modular languages support generative type abstraction,
ensuring that an abstract type is distinct from its
representation, except inside the implementation where the
two are synonymous.  We show that this well-established
feature is in tension with the non-parametric features
of newer type systems, such as indexed type families and GADTs.
In this paper we solve the problem by using kinds to 
distinguish between parametric and non-parametric contexts.
The result is directly applicable to Haskell, which is rapidly
developing support for type-level computation, but the same
issues should arise whenever generativity and non-parametric features
are combined.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="aydemir:lngen">5</a>]
</font></td>
<td class="bibtexitem">
Brian Aydemir and Stephanie Weirich.
 <b>LNgen: Tool Support for Locally Nameless Representations</b>.
 Technical Report MS-CIS-10-24, Computer and Information Science,
  University of Pennsylvania, June 2010.
[&nbsp;<a href="http://www.cis.upenn.edu/~sweirich/papers/lngen/">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_reports/933">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="teqt-tr">6</a>]
</font></td>
<td class="bibtexitem">
Aaron Stump, Vilhelm Sj&ouml;berg, and Stephanie Weirich.
 <b>Termination Casts: A Flexible Approach to Termination with
  General Recursion (Technical Appendix)</b>.
 Technical Report MS-CIS-10-21, University of Pennsylvania Department
  of Computer and Information Science, 2010.
[&nbsp;<a href="http://repository.upenn.edu/cis_reports/930/">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="aydemir:syntax">7</a>]
</font></td>
<td class="bibtexitem">
Brian Aydemir, Steve Zdancewic, and Stephanie Weirich.
 <b>Abstracting Syntax</b>.
 Technical Report MS-CIS-09-06, Computer and Information Science,
  University of Pennsylvania, March 2009.
[&nbsp;<a href="http://www.cis.upenn.edu/~sweirich/papers/abstracting-syntax/">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_reports/901/">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="InCertProposal07">8</a>]
</font></td>
<td class="bibtexitem">
Karl Crary, Robert Harper, Frank Pfenning, Benjamin&nbsp;C. Pierce, Stephanie
  Weirich, and Stephan Zdancewic.
 <b>Manifest Security</b>.
 Technical report, January 2007.
 White paper.
[&nbsp;<a href="http://www.cis.upenn.edu/~bcpierce/papers/manifestsecurity-whitepaper.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:boxy-techreport">9</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis, Stephanie Weirich, and Simon&nbsp;L. Peyton&nbsp;Jones.
 <b>Boxy type inference for higher-rank types and impredicativity,
  Technical Appendix</b>.
 Technical Report MS-CIS-05-23, University of Pennsylvania, April
  2006.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://www.cis.upenn.edu/~dimitriv/boxy/boxy-techreport.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:gadt-techreport">10</a>]
</font></td>
<td class="bibtexitem">
Dimitrios Vytiniotis, Stephanie Weirich, and Simon&nbsp;L. Peyton&nbsp;Jones.
 <b>Simple unification-based type inference for GADTs, Technical
  Appendix</b>.
 Technical Report MS-CIS-05-22, University of Pennsylvania, April
  2006.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://www.cis.upenn.edu/~dimitriv/wobbly/wobbly-techreport.pdf">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="peyton-jones:practical-tr">11</a>]
</font></td>
<td class="bibtexitem">
Simon&nbsp;L. Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Mark
  Shields.
 <b>Practical type inference for arbitrary-rank types (Technical
  appendix)</b>.
 Technical Report MIS-CIS-05-14, University of Pennsylvania, July
  2005.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://repository.upenn.edu/cis_reports/58/">PDF</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="washburn:seckinds-tr">12</a>]
</font></td>
<td class="bibtexitem">
Geoffrey Washburn and Stephanie Weirich.
 <b>Generalizing Parametricity Using Information Flow (Extended
  version)</b>.
 Technical Report MS-CIS-05-04, Computer and Information Science,
  University of Pennsylvania, July 2005.
[&nbsp;<a href="http://repository.upenn.edu/cis_reports/50/">PDF</a>&nbsp;]
<blockquote><font size="-1">
Run-time type analysis allows programmers to easily and
concisely define many operations based upon type structure, such as
serialization, iterators, and structural equality.  However, when
types can be inspected at run time, nothing is secret.  A module
writer cannot use type abstraction to hide implementation details from
clients: those clients can use type analysis to determine the
structure of these supposedly &ldquo;abstract&rdquo; data types.  Furthermore,
access control mechanisms do not help in isolating the implementation
of abstract datatypes from their clients.  Buggy or malicious
authorized modules may simply leak type information to unauthorized
clients, so module implementors cannot reliably tell which parts of a
program rely on their type definitions and which parts do not.<p>
Currently, module implementors rely on parametric polymorphism to
provide guarantees about the use of their abstract datatypes.
Standard type parametricity does not hold for a language with run-time
type analysis, but in this paper we show how to generalize the
statement of parametricity so that it does hold in the presence of
type analysis and still encompasses the integrity and confidentiality
policies that are normally derived from parametricity.  The key is to
augment the type system with annotations about information flow.
Because the type system tracks the flow of dynamic type information,
the implementor of an abstract data type can easily see what parts of
the program depend on the implementation of a given type.  

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="dantas:tech-report">13</a>]
</font></td>
<td class="bibtexitem">
Daniel&nbsp;S. Dantas, David Walker, Geoffrey Washburn, and Stephanie Weirich.
 <b>PolyAML: A Polymorphic Aspect-Oriented Functional Programming
  Language (Extended Version)</b>.
 Technical Report MS-CIS-05-07, University of Pennsylvania, Department
  of Computer and Information Science, 2005.
[&nbsp;<a href="http://repository.upenn.edu/cis_reports/51/">PDF</a>&nbsp;]
<blockquote><font size="-1">

This paper defines PolyAML, a typed functional, aspect-oriented programming language. The main contribution of PolyAML is the seamless integration of polymorphism, run-time type analysis and aspect-oriented programming language features. In particular, PolyAML allows programmers to define type-safe polymorphic advice using pointcuts constructed from a collection of polymorphic join points. PolyAML also comes equipped with a type inference algorithm that conservatively extends Hindley-Milner type inference. To support first-class polymorphic point-cut designators, a crucial feature for developing aspect-oriented profiling or logging libraries, the algorithm blends the conventional Hindley-Milner type inference algorithm with a simple form of local type inference.<p>
We give our language operational meaning via a type-directed translation into an expressive type-safe intermediate language. Many complexities of the source language are eliminated in this translation, leading to a modular specification of its semantics. One of the novelties of the intermediate language is the definition of polymorphic labels for marking control-flow points. These labels are organized in a tree structure such that a parent in the tree serves as a representative for all of its children. Type safety requires that the type of each child is less polymorphic than its parent type. Similarly, when a set of labels is assembled as a pointcut, the type of each label is an instance of the type of the pointcut.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="dantas:poly-aspects-tr">14</a>]
</font></td>
<td class="bibtexitem">
Dan&nbsp;S. Dantas, David Walker, Geoffrey Washburn, and Stephanie Weirich.
 <b>Analyzing Polymorphic Advice</b>.
 Technical Report TR-717-04, Princeton University Computer Science,
  December 2004.
[&nbsp;<a href="http://www.cs.princeton.edu/sip/projects/aspectml/">Project</a>&nbsp; 
<a href="http://ncstrl.cs.princeton.edu/expand.php?id=TR-717-04">PDF</a>&nbsp;]
<blockquote><font size="-1">
 We take one of the first steps towards developing a
   practical, statically-typed, functional, aspect-oriented
   programming language by showing how to integrate polymorphism and
   type analysis with aspect-oriented programming features.  In
   particular, we demonstrate how to define type-safe polymorphic
   advice using pointcuts that unify a collection of polymorphic join
   points.  We also introduce a new mechanism for specifying
   context-sensitive advice that involves pattern matching against the
   current stack of activation records, and meshes well with
   functional programming idioms.  We give our language meaning via a
   type-directed translation into an expressive, but fairly simple,
   type-safe intermediate language.  Many complexities of the source
   language are eliminated in this translation, leading to a modular
   specification of its semantics.  One of the novelties of the
   intermediate language is the definition of polymorphic labels for
   marking control-flow points.  These labels are organized in a tree
   structure such that a parent in the tree serves as a representative
   for the collection of all its children.  Type safety requires that
   the type of each child is a generic instance of the type of the
   polymorphic parent.  Similarly, when a set of labels is assembled
   as a pointcut, the type of each label is an instance of the type of
   the pointcut.
  
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="huang:tdp-tr">15</a>]
</font></td>
<td class="bibtexitem">
Liang Huang and Stephanie Weirich.
 <b>A Design for Type-Directed Programming in Java (Extended
  Version)</b>.
 Technical Report MS-CIS-04-11, University of Pennsylvania, Computer
  and Information Science, October 2004.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.ps">PS</a>&nbsp;]

</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="vytiniotis:itaname-tr">16</a>]
</font></td>
<td class="bibtexitem">
Dimtrios Vytiniotis, Geoffrey Washburn, and Stephanie Weirich.
 <b>An Open and Shut Typecase (Extended Version)</b>.
 Technical Report MS-CIS-04-26, University of Pennsylvania, Computer
  and Information Science, October 2004.
[&nbsp;<a href="http://repository.upenn.edu/cis_reports/27/">PDF</a>&nbsp; 
<a href="http://www.cis.upenn.edu/~dimitriv/itaname/itaname-extended.ps">PS</a>&nbsp;]
<blockquote><font size="-1">

Ad-hoc polymorphism is a compelling addition to typed programming languages. There are two different forms of ad-hoc polymorphism. With the nominal form, the execution of an operation is determined solely by the name of the type argument, whereas with the structural form, operations are defined by case analysis on the structure of types. The two forms differ in the way that they treat user-defined types. Operations defined by the nominal approach are considered "open"-the programmer can add cases for new types without modifying existing code. The operations must be extended however with specialized code for the new types, and it may be tedious and even difficult to add extensions that apply to a potentially large universe of user-defined types. Structurally defined operations apply to new types by treating them as equal to their underlying definitions, so no new cases for new types are necessary. However this form is considered "closed" to extension, as the behaviour of the operations cannot be differentiated for the new types. This form destroys the distinctions that user-defined types are designed to express. Both approaches have their benefits, so it is important to provide both capabilities in a single language that is expressive enough to decouple the "openness" issue from the way that user-defined types are treated. We present such a language that supports both forms of ad-hoc polymorphism.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="peyton-jones:wobbly">17</a>]
</font></td>
<td class="bibtexitem">
Simon&nbsp;L. Peyton Jones, Geoffrey Washburn, and Stephanie Weirich.
 <b>Wobbly types: Practical Type Inference for Generalised Algebraic
  Dataypes</b>.
 Technical Report MS-CIS-05-26, University of Pennsylvania, Computer
  and Information Science Department, Levine Hall, 3330 Walnut Street,
  Philadelphia, Pennsylvania, 19104-6389, July 2004.
[&nbsp;<a href="http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html">Project</a>&nbsp; 
<a href="http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-05-26.pdf">PDF</a>&nbsp;]
<blockquote><font size="-1">

Generalised algebraic data types (GADTs), sometimes known as &ldquo;guarded
recursive data types&rdquo; or &ldquo;first-class phantom types&rdquo;, are a simple
but powerful generalisation of the data types of Haskell and ML.
Recent works have given compelling examples of the utility of GADTs,
although type inference is known to be difficult.<p>
It is time to pluck the fruit.  Can GADTs be added to Haskell, without
losing type inference, or requiring unacceptably heavy type annotations?
Can this be done without completely rewriting the already-complex Haskell
type-inference engine, and without complex interactions with (say)
type classes?  We answer these questions in the affirmative, giving
a type system that explains just what type annotations are required,
and a prototype implementation that implements it.  Our main technical
innovation is <em>wobbly types</em>, which express in a declarative way
the uncertainty caused by the incremental nature of typical type-inference
algorithms.   

</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="washburn:itabox-tr">18</a>]
</font></td>
<td class="bibtexitem">
Geoffrey Washburn and Stephanie Weirich.
 <b>Boxes Go Bananas: Encoding Higher-order Abstract Syntax with
  Parametric Polymorphism (Extended version)</b>.
 Technical Report MS-CIS-03-26, University of Pennsylvania, Computer
  and Information Science, September 2003.
[&nbsp;<a href="http://repository.upenn.edu/cis_reports/43/">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/itabox/MS-CIS-03-26.ps">PS</a>&nbsp;]
<blockquote><font size="-1">
Higher-order abstract syntax is a simple technique for implementing languages with functional programming. Object variables and binders are implemented by variables and binders in the host language. By using this technique, one can avoid implementing common and tricky routines dealing with variables, such as capture-avoiding substitution. However, despite the advantages this technique provides, it is not commonly used because it is difficult to write sound elimination forms (such as folds or catamorphisms) for higher-order abstract syntax. To fold over such a datatype, one must either simultaneously define an inverse operation (which may not exist) or show that all functions embedded in the datatype are parametric.<p>
In this paper, we show how first-class polymorphism can be used to guarantee the parametricity of functions embedded in higher-order abstract syntax. With this restriction, we implement a library of iteration operators over data-structures containing functionals. From this implementation, we derive "fusion laws" that functional programmers may use to reason about the iteration operator. Finally, we show how this use of parametric polymorphism corresponds to the Schuermann, Despeyroux and Pfenning method of enforcing parametricity through modal types. We do so by using this library to give a sound and complete encoding of their calculus into System F-omega. This encoding can serve as a starting point for reasoning about higher-order structures in polymorphic languages.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="HicksW00type-loading-tr">19</a>]
</font></td>
<td class="bibtexitem">
Michael Hicks and Stephanie Weirich.
 <b>A Calculus for Dynamic Loading</b>.
 Technical Report MS-CIS-00-07, University of Pennsylvania, April
  2000.
[&nbsp;<a href=" http://repository.upenn.edu/cis_reports/169/ ">PDF</a>&nbsp;]
<blockquote><font size="-1">

We present the load-calculus, used to model dynamic loading, and prove it sound. The calculus extends the polymorphic lambda-calculus with a load primitive that dynamically loads terms that are closed, with respect to values. The calculus is meant to approximate the process of dynamic loading in TAL/Load , a version of Typed Assembly Language extending with dynamic linking. To model the key aspects of TAL, the calculus contains references and facilities for named types. Loadable programs may refer to named types defined by the running program, and may export new types to code loaded later. Our approach follows the framework initially outlined by Glew et. al. This calculus has been implemented in the TALx86 version of Typed Assembly Language, and is used to implement a full-featured dynamic linking library, DLpop.
</font></blockquote><p>
<p>
</font></td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="crary98a">20</a>]
</font></td>
<td class="bibtexitem">
Karl Crary, Stephanie Weirich, and Greg Morrisett.
 <b>Intensional Polymorphism in Type Erasure Semantics (Extended
  Version)</b>.
 Technical Report TR98-1721, Cornell University, Computer Science,
  November 1998.
[&nbsp;<a href="http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass-tr.pdf">PDF</a>&nbsp; 
<a href="http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass-tr.ps">PS</a>&nbsp;]

</font></td>
</tr>
</table><hr>

</td></tr>
<!-- This file contains the footer for the publications list -->

<tr><td width="100%" class="lightaqua" valign="middle" align="left">
<a name="COPY"></a>
<font size=3>Copyright Information</font><br>
<font size=2>
The documents contained in these directories are included by the
contributing authors as a means to ensure timely dissemination of
scholarly and technical work on a non-commercial basis. Copyright and
all rights therein are maintained by the authors or by other copyright
holders, notwithstanding that they have offered their works here
electronically. It is understood that all persons copying this
information will adhere to the terms and constraints invoked by each
author's copyright. These works may not be reposted without the
explicit permission of the copyright holder.
</font>
</td></tr>

<td width="100%" class="yellow" valign="middle" align="center">
<table border="0" cellpadding="0" cellspacing="0">
<tr>
<td width="50%" align="left">
<font size=1>
Parts of this page were generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 
</font>
</td>
<td width="50%" align="right">
<font size=1>

Last modified: 
Sat Jun 21 22:03:42 EDT 2014
</font></td></tr></table></table></center></html>
