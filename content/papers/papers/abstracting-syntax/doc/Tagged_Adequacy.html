<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Tagged_Adequacy</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Tagged_Adequacy</h1>

<code>
</code>

<div class="doc">
Adequacy of the tagged presentation with respect to our
    original locally nameless presentation.

<br/><br/>
    Author: Brian Aydemir (baydemir <code>at</code> cis.upenn.edu) 
</div>
<code>

<br/>
<span class="keyword">Require</span> <span class="keyword">Export</span> Omega.<br/>
<span class="keyword">Require</span> <span class="keyword">Export</span> <a class="modref" href="Fsub_LetSum_Soundness.html">Fsub_LetSum_Soundness</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Export</span> <a class="modref" href="Tagged_Soundness.html">Tagged_Soundness</a>.<br/>

<br/>
</code>

<div class="doc">
Because both developments use the same names, we use the module
    system to provide convenient shorthand prefixes that enable us to
    distinguish symbols.  The downside to doing this is that it seems
    to interfere with Coq's tactic automation, in ways I do not
    entirely understand. 
</div>
<code>

<br/>
<span class="keyword">Module</span> A   := Fsub_LetSum_Definitions.<br/>
<span class="keyword">Module</span> A'  := Fsub_LetSum_Infrastructure.<br/>
<span class="keyword">Module</span> A'' := Fsub_LetSum_Soundness.<br/>
<span class="keyword">Module</span> B   := Tagged_Definitions.<br/>
<span class="keyword">Module</span> B'  := Tagged_Infrastructure.<br/>
<span class="keyword">Module</span> B'' := Tagged_Soundness.<br/>

<br/>
</code>

<div class="doc">
<a name="lab205"></a><h1 class="section">Other infrastructure</h1>

</div>
<code>

<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="fv_spec"></a>fv_spec (Q A : tag) (T : B.syntax A) {struct T} : atoms :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> T <span class="keyword">with</span><br/>
&nbsp;&nbsp;| bvar _ J =&gt; {}<br/>
&nbsp;&nbsp;| fvar B X =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> eq_tag_dec Q B <span class="keyword">then</span> (singleton X) <span class="keyword">else</span> {}<br/>
&nbsp;&nbsp;| typ_top =&gt; {}<br/>
&nbsp;&nbsp;| typ_arrow T1 T2 =&gt; (fv_spec Q T1) `union` (fv_spec Q T2)<br/>
&nbsp;&nbsp;| typ_all T1 T2 =&gt; (fv_spec Q T1) `union` (fv_spec Q T2)<br/>
&nbsp;&nbsp;| typ_sum T1 T2 =&gt; (fv_spec Q T1) `union` (fv_spec Q T2)<br/>
&nbsp;&nbsp;| exp_abs V e1 =&gt; (fv_spec Q V) `union` (fv_spec Q e1)<br/>
&nbsp;&nbsp;| exp_app e1 e2 =&gt; (fv_spec Q e1) `union` (fv_spec Q e2)<br/>
&nbsp;&nbsp;| exp_tabs V e1 =&gt; (fv_spec Q V) `union` (fv_spec Q e1)<br/>
&nbsp;&nbsp;| exp_tapp e1 V =&gt; (fv_spec Q V) `union` (fv_spec Q e1)<br/>
&nbsp;&nbsp;| exp_let e1 e2 =&gt; (fv_spec Q e1) `union` (fv_spec Q e2)<br/>
&nbsp;&nbsp;| exp_inl e1 =&gt; (fv_spec Q e1)<br/>
&nbsp;&nbsp;| exp_inr e1 =&gt; (fv_spec Q e1)<br/>
&nbsp;&nbsp;| exp_case e1 e2 e3 =&gt; (fv_spec Q e1) `union` (fv_spec Q e2) `union` (fv_spec Q e3)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>

<br/>
</code>

<div class="doc">
<a name="lab206"></a><h1 class="section">Tactics</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
We redefine some tactics so that they are effective in our current
    setting. 
</div>
<code>

<br/>
<span class="keyword">Ltac</span> gather_atoms :=<br/>
&nbsp;&nbsp;<span class="keyword">let</span> A := gather_atoms_with (fun x : atoms =&gt; x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> B := gather_atoms_with (fun x : atom =&gt; singleton x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> C := gather_atoms_with (fun x : A.exp =&gt; A.fv_te x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> D := gather_atoms_with (fun x : A.exp =&gt; A.fv_ee x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> E := gather_atoms_with (fun x : A.typ =&gt; A.fv_tt x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> F := gather_atoms_with (fun x : A.senv =&gt; dom x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> G := gather_atoms_with (fun x : A.env =&gt; dom x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> H := gather_atoms_with (fun x : B.senv =&gt; dom x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> J := gather_atoms_with (fun x : B.env =&gt; dom x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> K := gather_atoms_with (fun x : B.typ =&gt; B.fv x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> K' := gather_atoms_with (fun x : B.exp =&gt; B.fv x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> L1 := gather_atoms_with (fun x : B.typ =&gt; @fv_spec Typ Typ x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> L2 := gather_atoms_with (fun x : B.typ =&gt; @fv_spec Exp Typ x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> L3 := gather_atoms_with (fun x : B.exp =&gt; @fv_spec Typ Exp x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;<span class="keyword">let</span> L4 := gather_atoms_with (fun x : B.exp =&gt; @fv_spec Exp Exp x) <span class="keyword">in</span><br/>
&nbsp;&nbsp;constr:(A `union` B `union` C `union` D `union`<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E `union` F `union` G `union` H `union` J `union` K `union`<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K' `union` L1 `union` L2 `union` L3 `union` L4).<br/>

<br/>
<span class="keyword">Tactic Notation</span> "pick" "fresh" ident(x) :=<br/>
&nbsp;&nbsp;<span class="keyword">let</span> L := gather_atoms <span class="keyword">in</span> (pick fresh x for L).<br/>

<br/>
<span class="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pick" "fresh" ident(atom_name) "and" "apply" constr(lemma) :=<br/>
&nbsp;&nbsp;<span class="keyword">let</span> L := gather_atoms <span class="keyword">in</span><br/>
&nbsp;&nbsp;pick fresh atom_name excluding L and apply lemma.<br/>

<br/>
</code>

<div class="doc">
<a name="lab207"></a><h1 class="section">Other infrastructure</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab208"></a><h1 class="section">Other infrastructure</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
We prove some induction principles for the tagged representation, becuase
    Coq does not automatically provide them. 
</div>
<code>

<br/>
<span class="keyword">Section</span> Typ_induction.<br/>

<br/>
<span class="keyword">Variables</span><br/>
&nbsp;&nbsp;(P : typ -&gt; Prop)<br/>
&nbsp;&nbsp;(Hbvar : forall (n : nat), P (bvar n))<br/>
&nbsp;&nbsp;(Hfvar : forall (a : atom), P (fvar a))<br/>
&nbsp;&nbsp;(Htop : P typ_top)<br/>
&nbsp;&nbsp;(Harrow : forall s : typ,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt; forall s0 : typ, P s0 -&gt; P (typ_arrow s s0))<br/>
&nbsp;&nbsp;(Hall : forall s : typ,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt; forall s0 : typ, P s0 -&gt; P (typ_all s s0))<br/>
&nbsp;&nbsp;(Hsum : forall s : typ,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt; forall s0 : typ, P s0 -&gt; P (typ_sum s s0)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_ind_aux"></a>typ_ind_aux : forall (t : tag) (e : syntax t),<br/>
&nbsp;&nbsp;(fun (t : tag) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">return</span> syntax t -&gt; <span class="keyword">Prop</span> <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typ =&gt; (fun t =&gt; P t)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Exp =&gt; (fun _ =&gt; True)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end) t e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_ind"></a>typ_ind :<br/>
&nbsp;&nbsp;forall (T : typ),  P T.<br/>

<br/>
<span class="keyword">End</span> Typ_induction.<br/>

<br/>
<span class="keyword">Section</span> Exp_induction.<br/>
<span class="keyword">Variables</span><br/>
&nbsp;&nbsp;(P : exp -&gt; Prop)<br/>
&nbsp;&nbsp;(Hbvar : forall (n : nat), P (bvar n))<br/>
&nbsp;&nbsp;(Hfvar : forall (a : atom), P (fvar a))<br/>
&nbsp;&nbsp;(Habs : forall s : typ, forall s0 : exp, P s0 -&gt; P (exp_abs s s0))<br/>
&nbsp;&nbsp;(Happ : forall s : exp,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt; forall s0 : exp, P s0 -&gt; P (exp_app s s0))<br/>
&nbsp;&nbsp;(Htabs : forall s : typ,<br/>
&nbsp;&nbsp;&nbsp;forall s0 : exp, P s0 -&gt; P (exp_tabs s s0))<br/>
&nbsp;&nbsp;(Htapp : forall s : exp, forall s0 : typ,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt; P (exp_tapp s s0))<br/>
&nbsp;&nbsp;(Hlet : forall s : exp,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt; forall s0 : exp, P s0 -&gt; P (exp_let s s0))<br/>
&nbsp;&nbsp;(Hinl : forall s : exp, P s -&gt; P (exp_inl s))<br/>
&nbsp;&nbsp;(Hinr : forall s : exp, P s -&gt; P (exp_inr s))<br/>
&nbsp;&nbsp;(Hcase : forall s : exp,<br/>
&nbsp;&nbsp;&nbsp;P s -&gt;<br/>
&nbsp;&nbsp;&nbsp;forall s0 : exp,<br/>
&nbsp;&nbsp;&nbsp;P s0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;forall s1 : exp, P s1 -&gt; P (exp_case s s0 s1)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_ind_aux"></a>exp_ind_aux : forall (t : tag) (e : syntax t),<br/>
&nbsp;&nbsp;(fun (t : tag) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">return</span> syntax t -&gt; <span class="keyword">Prop</span> <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typ =&gt; (fun _ =&gt; True)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Exp =&gt; (fun e =&gt; P e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end) t e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_ind"></a>exp_ind :<br/>
&nbsp;&nbsp;forall (e : exp), P e.<br/>

<br/>
<span class="keyword">End</span> Exp_induction.<br/>

<br/>
<span class="keyword">Section</span> Typ_lc_induction.<br/>

<br/>
<span class="keyword">Variables</span><br/>
&nbsp;&nbsp;(P : typ -&gt; Prop)<br/>
&nbsp;&nbsp;(Hvar : forall (X : atom), P (typ_fvar X))<br/>
&nbsp;&nbsp;(Htop : P typ_top)<br/>
&nbsp;&nbsp;(Harrow : forall T1 T2 : typ,<br/>
&nbsp;&nbsp;&nbsp;lc T1 -&gt; P T1 -&gt; lc T2 -&gt; P T2 -&gt; P (typ_arrow T1 T2))<br/>
&nbsp;&nbsp;(Hall : forall (L : atoms) (T1 T2 : typ),<br/>
&nbsp;&nbsp;&nbsp;lc T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;P T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall X : atom, X `notin` L -&gt; lc (open T2 (typ_fvar X))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall X : atom, X `notin` L -&gt; P (open T2 (typ_fvar X))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;P (typ_all T1 T2))<br/>
&nbsp;&nbsp;(Hsum : forall T1 T2 : typ,<br/>
&nbsp;&nbsp;&nbsp;lc T1 -&gt; P T1 -&gt; lc T2 -&gt; P T2 -&gt; P (typ_sum T1 T2)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_lc_ind_aux"></a>typ_lc_ind_aux : forall (t : tag) (e : syntax t),<br/>
&nbsp;&nbsp;lc e -&gt;<br/>
&nbsp;&nbsp;(fun (t : tag) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">return</span> syntax t -&gt; <span class="keyword">Prop</span> <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typ =&gt; (fun t =&gt; P t)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Exp =&gt; (fun _ =&gt; True)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end) t e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_lc_ind"></a>typ_lc_ind :<br/>
&nbsp;&nbsp;forall (T : typ), lc T -&gt; P T.<br/>

<br/>
<span class="keyword">End</span> Typ_lc_induction.<br/>

<br/>
<span class="keyword">Section</span> Exp_lc_induction.<br/>

<br/>
<span class="keyword">Variables</span><br/>
&nbsp;&nbsp;(P : exp -&gt; Prop)<br/>
&nbsp;&nbsp;(Hvar : forall (X : atom), P (exp_fvar X))<br/>
&nbsp;&nbsp;(Habs : forall (L : atoms) (T : typ) (e1 : exp),<br/>
&nbsp;&nbsp;&nbsp;lc T -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; lc (open e1 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; P (open e1 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;P (exp_abs T e1))<br/>
&nbsp;&nbsp;(Happ : forall e1 e2 : exp,<br/>
&nbsp;&nbsp;&nbsp;lc e1 -&gt; P e1 -&gt; lc e2 -&gt; P e2 -&gt; P (exp_app e1 e2))<br/>
&nbsp;&nbsp;(Htabs : forall (L : atoms) (T : typ) (e1 : exp),<br/>
&nbsp;&nbsp;&nbsp;lc T -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall X : atom, X `notin` L -&gt; lc (open e1 (typ_fvar X))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall X : atom, X `notin` L -&gt; P (open e1 (typ_fvar X))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;P (exp_tabs T e1))<br/>
&nbsp;&nbsp;(Htapp : forall (e1 : exp) (V : typ),<br/>
&nbsp;&nbsp;&nbsp;lc e1 -&gt; P e1 -&gt; lc V -&gt; P (exp_tapp e1 V))<br/>
&nbsp;&nbsp;(Hlet : forall (L : atoms) (e1 e2 : exp),<br/>
&nbsp;&nbsp;&nbsp;lc e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;P e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; lc (open e2 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; P (open e2 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;P (exp_let e1 e2))<br/>
&nbsp;&nbsp;(Hinl : forall e1 : exp, lc e1 -&gt; P e1 -&gt; P (exp_inl e1))<br/>
&nbsp;&nbsp;(Hinr : forall e1 : exp, lc e1 -&gt; P e1 -&gt; P (exp_inr e1))<br/>
&nbsp;&nbsp;(Hcase : forall (L : atoms) (e1 e2 e3 : exp),<br/>
&nbsp;&nbsp;&nbsp;lc e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;P e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; lc (open e2 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; P (open e2 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; lc (open e3 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt; P (open e3 (exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;P (exp_case e1 e2 e3)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_lc_ind_aux"></a>exp_lc_ind_aux : forall (t : tag) (e : syntax t),<br/>
&nbsp;&nbsp;lc e -&gt;<br/>
&nbsp;&nbsp;(fun (t : tag) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">return</span> syntax t -&gt; <span class="keyword">Prop</span> <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Typ =&gt; (fun _ =&gt; True)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Exp =&gt; (fun e =&gt; P e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end) t e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_lc_ind"></a>exp_lc_ind :<br/>
&nbsp;&nbsp;forall (e : exp), lc e -&gt; P e.<br/>

<br/>
<span class="keyword">End</span> Exp_lc_induction.<br/>

<br/>
</code>

<div class="doc">
Opening a term with a variable is an injective operation if the
    variable is sufficiently fresh. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="open_tt_injective_rec"></a>open_tt_injective_rec : forall T S k (X : atom),<br/>
&nbsp;&nbsp;X `notin` (A.fv_tt T `union` A.fv_tt S) -&gt;<br/>
&nbsp;&nbsp;A.open_tt_rec k X T = A.open_tt_rec k X S -&gt;<br/>
&nbsp;&nbsp;T = S.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_tt_injective"></a>open_tt_injective : forall T S (X : atom),<br/>
&nbsp;&nbsp;X `notin` (A.fv_tt T `union` A.fv_tt S) -&gt;<br/>
&nbsp;&nbsp;A.open_tt T X = A.open_tt S X -&gt;<br/>
&nbsp;&nbsp;T = S.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_te_injective_rec"></a>open_te_injective_rec : forall e f k (X : atom),<br/>
&nbsp;&nbsp;X `notin` (A.fv_te e `union` A.fv_te f) -&gt;<br/>
&nbsp;&nbsp;A.open_te_rec k X e = A.open_te_rec k X f -&gt;<br/>
&nbsp;&nbsp;e = f.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_te_injective"></a>open_te_injective : forall e f (X : atom),<br/>
&nbsp;&nbsp;X `notin` (A.fv_te e `union` A.fv_te f) -&gt;<br/>
&nbsp;&nbsp;A.open_te e X = A.open_te f X -&gt;<br/>
&nbsp;&nbsp;e = f.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_ee_injective_rec"></a>open_ee_injective_rec : forall e f k (X : atom),<br/>
&nbsp;&nbsp;X `notin` (A.fv_ee e `union` A.fv_ee f) -&gt;<br/>
&nbsp;&nbsp;A.open_ee_rec k X e = A.open_ee_rec k X f -&gt;<br/>
&nbsp;&nbsp;e = f.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_ee_injective"></a>open_ee_injective : forall e f (X : atom),<br/>
&nbsp;&nbsp;X `notin` (A.fv_ee e `union` A.fv_ee f) -&gt;<br/>
&nbsp;&nbsp;A.open_ee e X = A.open_ee f X -&gt;<br/>
&nbsp;&nbsp;e = f.<br/>

<br/>
<span class="keyword">Ltac</span> repair_goal :=<br/>
&nbsp;&nbsp;change typ_arrow <span class="keyword">with</span> B.typ_arrow;<br/>
&nbsp;&nbsp;change typ_all <span class="keyword">with</span> B.typ_all;<br/>
&nbsp;&nbsp;change typ_sum <span class="keyword">with</span> B.typ_sum;<br/>
&nbsp;&nbsp;change exp_abs <span class="keyword">with</span> B.exp_abs;<br/>
&nbsp;&nbsp;change exp_app <span class="keyword">with</span> B.exp_app;<br/>
&nbsp;&nbsp;change exp_tabs <span class="keyword">with</span> B.exp_tabs;<br/>
&nbsp;&nbsp;change exp_tapp <span class="keyword">with</span> B.exp_tapp;<br/>
&nbsp;&nbsp;change exp_let <span class="keyword">with</span> B.exp_let;<br/>
&nbsp;&nbsp;change exp_inl <span class="keyword">with</span> B.exp_inl;<br/>
&nbsp;&nbsp;change exp_inr <span class="keyword">with</span> B.exp_inr;<br/>
&nbsp;&nbsp;change exp_case <span class="keyword">with</span> B.exp_case.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_injective_rec"></a>open_injective_rec :<br/>
&nbsp;&nbsp;forall A B (T : B.syntax A) (S : B.syntax A) k (X : atom),<br/>
&nbsp;&nbsp;X `notin` (B.fv T `union` B.fv S) -&gt;<br/>
&nbsp;&nbsp;B.open_rec k (@B.fvar B X) T = B.open_rec k (@B.fvar B X) S -&gt;<br/>
&nbsp;&nbsp;T = S.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_injective"></a>open_injective : forall A B (T S : B.syntax A) (X : atom),<br/>
&nbsp;&nbsp;X `notin` (B.fv T `union` B.fv S) -&gt;<br/>
&nbsp;&nbsp;B.open T (@B.fvar B X) = B.open S (@B.fvar B X) -&gt;<br/>
&nbsp;&nbsp;T = S.<br/>

<br/>
</code>

<div class="doc">
Lemmas about substitution. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="subst_tt_fresh"></a>subst_tt_fresh : forall Z (U : B.typ) (T : B.typ),<br/>
&nbsp;&nbsp;&nbsp;Z `notin` fv_spec Typ T -&gt;<br/>
&nbsp;&nbsp;&nbsp;T = B.subst_tt Z U T.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_et_fresh"></a>subst_et_fresh : forall Z (U : B.exp) (T : B.typ),<br/>
&nbsp;&nbsp;&nbsp;Z `notin` fv_spec Exp T -&gt;<br/>
&nbsp;&nbsp;&nbsp;T = B.subst_tt Z U T.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_te_fresh"></a>subst_te_fresh : forall Z (U : B.typ) (T : B.exp),<br/>
&nbsp;&nbsp;&nbsp;Z `notin` fv_spec Typ T -&gt;<br/>
&nbsp;&nbsp;&nbsp;T = B.subst_te Z U T.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_ee_fresh"></a>subst_ee_fresh : forall Z (U : B.exp) (T : B.exp),<br/>
&nbsp;&nbsp;&nbsp;Z `notin` fv_spec Exp T -&gt;<br/>
&nbsp;&nbsp;&nbsp;T = B.subst_ee Z U T.<br/>

<br/>
</code>

<div class="doc">
<a name="lab209"></a><h1 class="section">Level</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab210"></a><h2 class="section">Definitions</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
A term is at level <code>n</code> if the greatest index in the term is
    strictly less than <code>n</code>. 
</div>
<code>

<br/>
<span class="keyword">Inductive</span> <a name="level_t"></a>level_t : nat -&gt; A.typ -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| level_t_top : forall n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n A.typ_top<br/>
&nbsp;&nbsp;| level_t_bvar : forall n i,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i &lt; n -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n (A.typ_bvar i)<br/>
&nbsp;&nbsp;| level_t_fvar : forall n X,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n (A.typ_fvar X)<br/>
&nbsp;&nbsp;| level_t_arrow : forall n T1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n (A.typ_arrow T1 T2)<br/>
&nbsp;&nbsp;| level_t_all : forall n T1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t (S n) T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n (A.typ_all T1 T2)<br/>
&nbsp;&nbsp;| level_t_sum : forall n T1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n (A.typ_sum T1 T2).<br/>

<br/>
<span class="keyword">Hint</span> Constructors level_t.<br/>

<br/>
<span class="keyword">Inductive</span> <a name="level_e"></a>level_e : nat -&gt; A.exp -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| level_e_bvar : forall n i,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i &lt; n -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_bvar i)<br/>
&nbsp;&nbsp;| level_e_fvar : forall n X,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_fvar X)<br/>
&nbsp;&nbsp;| level_e_abs : forall n T e,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e (S n) e -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_abs T e)<br/>
&nbsp;&nbsp;| level_e_app : forall n e1 e2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_app e1 e2)<br/>
&nbsp;&nbsp;| level_e_tabs : forall n T e,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e (S n) e -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_tabs T e)<br/>
&nbsp;&nbsp;| level_e_tapp : forall n e1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_t n T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_tapp e1 T2)<br/>
&nbsp;&nbsp;| level_e_let : forall n e1 e2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e (S n) e2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_let e1 e2)<br/>
&nbsp;&nbsp;| level_e_inl : forall n e1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_inl e1)<br/>
&nbsp;&nbsp;| level_e_inr : forall n e1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_inr e1)<br/>
&nbsp;&nbsp;| level_e_case : forall n e1 e2 e3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e (S n) e2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e (S n) e3 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level_e n (A.exp_case e1 e2 e3).<br/>

<br/>
<span class="keyword">Hint</span> Constructors level_e.<br/>

<br/>

<br/>
<span class="keyword">Inductive</span> <a name="level"></a>level : forall A, nat -&gt; B.syntax A -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| level_bvar : forall A n i,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i &lt; n -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (@B.bvar A i)<br/>
&nbsp;&nbsp;| level_fvar : forall A n X,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (@B.fvar A X)<br/>
&nbsp;&nbsp;| level_top : forall n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n B.typ_top<br/>
&nbsp;&nbsp;| level_arrow : forall n T1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.typ_arrow T1 T2)<br/>
&nbsp;&nbsp;| level_all : forall n T1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level (S n) T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.typ_all T1 T2)<br/>
&nbsp;&nbsp;| level_sum : forall n T1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.typ_sum T1 T2)<br/>
&nbsp;&nbsp;| level_abs : forall n T e,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level (S n) e -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_abs T e)<br/>
&nbsp;&nbsp;| level_app : forall n e1 e2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_app e1 e2)<br/>
&nbsp;&nbsp;| level_tabs : forall n T e,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level (S n) e -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_tabs T e)<br/>
&nbsp;&nbsp;| level_tapp : forall n e1 T2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n T2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_tapp e1 T2)<br/>
&nbsp;&nbsp;| level_let : forall n e1 e2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level (S n) e2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_let e1 e2)<br/>
&nbsp;&nbsp;| level_inl : forall n e1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_inl e1)<br/>
&nbsp;&nbsp;| level_inr : forall n e1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_inr e1)<br/>
&nbsp;&nbsp;| level_case : forall n e1 e2 e3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n e1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level (S n) e2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level (S n) e3 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level n (B.exp_case e1 e2 e3).<br/>

<br/>
<span class="keyword">Hint</span> Constructors level.<br/>

<br/>

<br/>
<span class="keyword">Hint</span> Constructors level.<br/>

<br/>
</code>

<div class="doc">
<a name="lab211"></a><h2 class="section">Properties</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
A term at level <code>n</code> is also a term at level <code>(S n)</code>. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="level_t_promote"></a>level_t_promote : forall n T,<br/>
&nbsp;&nbsp;level_t n T -&gt;<br/>
&nbsp;&nbsp;level_t (S n) T.<br/>

<br/>
<span class="keyword">Hint</span> Resolve level_t_promote.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="level_e_promote"></a>level_e_promote : forall n e,<br/>
&nbsp;&nbsp;level_e n e -&gt;<br/>
&nbsp;&nbsp;level_e (S n) e.<br/>

<br/>
<span class="keyword">Hint</span> Resolve level_e_promote.<br/>

<br/>
</code>

<div class="doc">
The following lemmas establish the relationship between the level
    of a term and opening. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="level_t_open_tt"></a>level_t_open_tt : forall T2 n (X : atom),<br/>
&nbsp;&nbsp;level_t n (A.open_tt_rec n X T2) -&gt;<br/>
&nbsp;&nbsp;level_t (S n) T2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="level_e_open_te"></a>level_e_open_te : forall e n (x : atom),<br/>
&nbsp;&nbsp;level_e n (A.open_te_rec n x e) -&gt;<br/>
&nbsp;&nbsp;level_e (S n) e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="level_e_open_ee"></a>level_e_open_ee : forall e n (x : atom),<br/>
&nbsp;&nbsp;level_e n (A.open_ee_rec n x e) -&gt;<br/>
&nbsp;&nbsp;level_e (S n) e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="level_open"></a>level_open : forall A B (T : B.syntax A) n (X : atom),<br/>
&nbsp;&nbsp;level n (B.open_rec n (@B.fvar B X) T) -&gt;<br/>
&nbsp;&nbsp;level (S n) T.<br/>

<br/>
</code>

<div class="doc">
Locally closed terms are at level 0. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="level_t_of_type"></a>level_t_of_type : forall T,<br/>
&nbsp;&nbsp;A.type T -&gt; level_t 0 T.<br/>

<br/>
<span class="keyword">Hint</span> Resolve level_t_of_type.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="level_e_of_expr"></a>level_e_of_expr : forall e,<br/>
&nbsp;&nbsp;A.expr e -&gt; level_e 0 e.<br/>

<br/>
<span class="keyword">Hint</span> Resolve level_e_of_expr.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="level_of_lc"></a>level_of_lc : forall A (T : syntax A),<br/>
&nbsp;&nbsp;@B.lc A T -&gt; @level A 0 T.<br/>

<br/>
<span class="keyword">Hint</span> Resolve level_of_lc.<br/>

<br/>
</code>

<div class="doc">
<a name="lab212"></a><h1 class="section">Closing</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab213"></a><h2 class="section">Definitions</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
Closing replaces a free variable with an index.  The definition
    below assumes that <code>K</code> is greater than the greatest index
    appearing in <code>T</code>. 
</div>
<code>

<br/>
<span class="keyword">Fixpoint</span> <a name="close_tt_rec"></a>close_tt_rec (K : nat) (X : atom) (T : A.typ) {struct T} : A.typ :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> T <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.typ_top =&gt; A.typ_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.typ_bvar n =&gt; A.typ_bvar n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.typ_fvar Y =&gt; <span class="keyword">if</span> X == Y <span class="keyword">then</span> (A.typ_bvar K) <span class="keyword">else</span> (A.typ_fvar Y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.typ_arrow T1 T2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.typ_arrow (close_tt_rec K X T1) (close_tt_rec K X T2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.typ_all T1 T2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.typ_all (close_tt_rec K X T1) (close_tt_rec (S K) X T2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.typ_sum T1 T2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.typ_sum (close_tt_rec K X T1) (close_tt_rec K X T2)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="close_tt"></a>close_tt T X := close_tt_rec 0 X T.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="close_te_rec"></a>close_te_rec (k : nat) (X : atom) (e : A.exp) {struct e} : A.exp :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> e <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_bvar n =&gt; A.exp_bvar n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_fvar x =&gt; A.exp_fvar x<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_abs T e =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_abs (close_tt_rec k X T) (close_te_rec (S k) X e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_app e1 e2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_app (close_te_rec k X e1) (close_te_rec k X e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_tabs T e =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_tabs (close_tt_rec k X T) (close_te_rec (S k) X e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_tapp e1 T2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_tapp (close_te_rec k X e1) (close_tt_rec k X T2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_let e1 e2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_let (close_te_rec k X e1) (close_te_rec (S k) X e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_inl e1 =&gt; A.exp_inl (close_te_rec k X e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_inr e1 =&gt; A.exp_inr (close_te_rec k X e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_case e1 e2 e3 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_case (close_te_rec k X e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close_te_rec (S k) X e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close_te_rec (S k) X e3)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="close_te"></a>close_te e X := close_te_rec 0 X e.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="close_ee_rec"></a>close_ee_rec (k : nat) (y : atom) (e : A.exp) {struct e} : A.exp :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> e <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_bvar n =&gt; A.exp_bvar n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_fvar x =&gt; <span class="keyword">if</span> y == x <span class="keyword">then</span> (A.exp_bvar k) <span class="keyword">else</span> (A.exp_fvar x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_abs T e =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_abs T (close_ee_rec (S k) y e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_app e1 e2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_app (close_ee_rec k y e1) (close_ee_rec k y e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_tabs T e =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_tabs T (close_ee_rec (S k) y e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_tapp e1 T2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_tapp (close_ee_rec k y e1) T2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_let e1 e2 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_let (close_ee_rec k y e1) (close_ee_rec (S k) y e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_inl e1 =&gt; A.exp_inl (close_ee_rec k y e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_inr e1 =&gt; A.exp_inr (close_ee_rec k y e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| A.exp_case e1 e2 e3 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.exp_case (close_ee_rec k y e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close_ee_rec (S k) y e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close_ee_rec (S k) y e3)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="close_ee"></a>close_ee e y := close_ee_rec 0 y e.<br/>

<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="close_rec"></a>close_rec<br/>
&nbsp;&nbsp;A B (K : nat) (X : atom) (t : B.syntax A) {struct t} : B.syntax A :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> t <span class="keyword">in</span> B.syntax A <span class="keyword">return</span> B.syntax A <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.bvar _ n =&gt; B.bvar n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.fvar A Y =&gt; <span class="keyword">if</span> X == Y <span class="keyword">then</span> @tagCheck B A (@B.bvar B K) (@B.fvar A Y) <span class="keyword">else</span> (B.fvar Y)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.typ_top =&gt; B.typ_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.typ_arrow T1 T2 =&gt; B.typ_arrow (close_rec B K X T1) (close_rec B K X T2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.typ_all T1 T2 =&gt; B.typ_all (close_rec B K X T1) (close_rec B (S K) X T2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.typ_sum T1 T2 =&gt; B.typ_sum (close_rec B K X T1) (close_rec B K X T2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_abs T e =&gt; B.exp_abs (close_rec B K X T) (close_rec B (S K) X e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_app e1 e2 =&gt; B.exp_app (close_rec B K X e1) (close_rec B K X e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_tabs T e =&gt; B.exp_tabs (close_rec B K X T) (close_rec B (S K) X e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_tapp e T =&gt; B.exp_tapp (close_rec B K X e) (close_rec B K X T)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_let e1 e2 =&gt; B.exp_let (close_rec B K X e1) (close_rec B (S K) X e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_inl e1 =&gt; B.exp_inl (close_rec B K X e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_inr e1 =&gt; B.exp_inr (close_rec B K X e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| B.exp_case e1 e2 e3 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B.exp_case (close_rec B K X e1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close_rec B (S K) X e2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close_rec B (S K) X e3)<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="close"></a>close A B (T : B.syntax A) X := @close_rec A B 0 X T.<br/>

<br/>

<br/>
</code>

<div class="doc">
<a name="lab214"></a><h2 class="section">Properties</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
Opening and closing are inverses of each other under certain
    conditions. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="open_tt_close_tt_inv_rec"></a>open_tt_close_tt_inv_rec : forall (T : A.typ) (K : nat) (X : atom),<br/>
&nbsp;&nbsp;level_t K T -&gt;<br/>
&nbsp;&nbsp;A.open_tt_rec K (A.typ_fvar X) (close_tt_rec K X T) = T.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_tt_close_tt_inv"></a>open_tt_close_tt_inv : forall (T : A.typ) (X : atom),<br/>
&nbsp;&nbsp;A.type T -&gt;<br/>
&nbsp;&nbsp;A.open_tt (close_tt T X) X = T.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_te_close_te_inv_rec"></a>open_te_close_te_inv_rec : forall (e : A.exp) (K : nat) (X : atom),<br/>
&nbsp;&nbsp;level_e K e -&gt;<br/>
&nbsp;&nbsp;A.open_te_rec K (A.typ_fvar X) (close_te_rec K X e) = e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_te_close_te_inv"></a>open_te_close_te_inv : forall (e : A.exp) (X : atom),<br/>
&nbsp;&nbsp;A.expr e -&gt;<br/>
&nbsp;&nbsp;A.open_te (close_te e X) X = e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_ee_close_ee_inv_rec"></a>open_ee_close_ee_inv_rec : forall (e : A.exp) (k : nat) (x : atom),<br/>
&nbsp;&nbsp;level_e k e -&gt;<br/>
&nbsp;&nbsp;A.open_ee_rec k (A.exp_fvar x) (close_ee_rec k x e) = e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_ee_close_ee_inv"></a>open_ee_close_ee_inv : forall (e : A.exp) (x : atom),<br/>
&nbsp;&nbsp;A.expr e -&gt;<br/>
&nbsp;&nbsp;A.open_ee (close_ee e x) x = e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_close_inv_rec"></a>open_close_inv_rec : forall A B (t : B.syntax A) (K : nat) (X : atom),<br/>
&nbsp;&nbsp;level K t -&gt;<br/>
&nbsp;&nbsp;B.open_rec K (@B.fvar B X) (close_rec B K X t) = t.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="open_close_inv"></a>open_close_inv : forall A B (e : B.syntax A) (X : atom),<br/>
&nbsp;&nbsp;B.lc e -&gt;<br/>
&nbsp;&nbsp;@B.open B A (@close A B e X) (@fvar B X) = e.<br/>

<br/>
</code>

<div class="doc">
If we close a term with a particular name, that name will be fresh
    for the result. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="close_tt_fresh_rec"></a>close_tt_fresh_rec : forall (T : A.typ) (K : nat) (X : atom),<br/>
&nbsp;&nbsp;X `notin` A.fv_tt (close_tt_rec K X T).<br/>

<br/>
<span class="keyword">Hint</span> Resolve close_tt_fresh_rec.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_tt_fresh"></a>close_tt_fresh : forall (T : A.typ) (X : atom),<br/>
&nbsp;&nbsp;X `notin` A.fv_tt (close_tt T X).<br/>

<br/>
<span class="keyword">Hint</span> Resolve close_tt_fresh.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_te_fresh_te_rec"></a>close_te_fresh_te_rec : forall e1 (X : atom) (k : nat),<br/>
&nbsp;&nbsp;X `notin` A.fv_te (close_te_rec k X e1).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_te_fresh_te"></a>close_te_fresh_te : forall e1 (X : atom),<br/>
&nbsp;&nbsp;X `notin` A.fv_te (close_te e1 X).<br/>

<br/>
<span class="keyword">Hint</span> Resolve close_te_fresh_te.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_ee_fresh_ee_rec"></a>close_ee_fresh_ee_rec : forall e1 (x : atom) (k : nat),<br/>
&nbsp;&nbsp;x `notin` A.fv_ee (close_ee_rec k x e1).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_ee_fresh_ee"></a>close_ee_fresh_ee : forall e1 (x : atom),<br/>
&nbsp;&nbsp;x `notin` A.fv_ee (close_ee e1 x).<br/>

<br/>
<span class="keyword">Hint</span> Resolve close_ee_fresh_ee.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_fresh_rec"></a>close_fresh_rec : forall A B (t : B.syntax A) (K : nat) (X : atom),<br/>
&nbsp;&nbsp;X `notin` @fv_spec B A (close_rec B K X t).<br/>

<br/>
<span class="keyword">Hint</span> Resolve close_fresh_rec.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="close_fresh"></a>close_fresh : forall A B (t : B.syntax A) (X : atom),<br/>
&nbsp;&nbsp;X `notin` @fv_spec B A (close B t X).<br/>

<br/>
<span class="keyword">Hint</span> Resolve close_fresh.<br/>

<br/>
</code>

<div class="doc">
<a name="lab215"></a><h1 class="section">Bijection on senvs</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
In general, two developments may use different environments (given
    by the type <code>senv</code> in each development, according to our naming
    convention) for checking the well-formedness of Fsub types and
    expressions.  In order to define the bijection between Fsub terms,
    we need a bijection on <code>senv</code>s. 
</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab216"></a><h2 class="section">Definition</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
The definition here is trivial because <code>A.senv</code> and <code>B.senv</code> are
    the same type.  The definition specifically does not check that
    the environments are ok; that must be done elsewhere. 
</div>
<code>

<br/>
<span class="keyword">Inductive</span> <a name="senv_bijection"></a>senv_bijection : A.senv -&gt; B.senv -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| senv_bijection_refl : forall E,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;senv_bijection E E.<br/>

<br/>
<span class="keyword">Hint</span> Constructors senv_bijection.<br/>

<br/>
</code>

<div class="doc">
<a name="lab217"></a><h2 class="section">Properties</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
We define a tactic for simplifying <code>senv_bijection</code> propositions
    in the hypothesis list. 
</div>
<code>

<br/>
<span class="keyword">Ltac</span> simplify_senv_bijection :=<br/>
&nbsp;&nbsp;<span class="keyword">match</span> goal <span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| H : senv_bijection ?E ?F |- _ =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inversion H; try subst F; try subst; clear H; simplify_senv_bijection<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idtac<br/>
&nbsp;&nbsp;<span class="keyword">end</span>.<br/>

<br/>
</code>

<div class="doc">
The bijection respects environment concatentation. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="senv_bijection_app"></a>senv_bijection_app : forall E E' F F',<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F' -&gt;<br/>
&nbsp;&nbsp;senv_bijection (E ++ F) (E' ++ F').<br/>

<br/>
<span class="keyword">Hint</span> Resolve senv_bijection_app.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="senv_bijection_length"></a>senv_bijection_length : forall E E',<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;length E = length E'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="senv_bijection_head"></a>senv_bijection_head : forall E E' F F',<br/>
&nbsp;&nbsp;senv_bijection (F ++ E) (F' ++ E') -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F'.<br/>

<br/>
</code>

<div class="doc">
<a name="lab218"></a><h1 class="section">Bijection on types</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
We first define a relation on well-formed Fsub types and then show that
    the relation defines a bijection on such terms. 
</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab219"></a><h2 class="section">Definition</h2>

</div>
<code>

<br/>
<span class="keyword">Inductive</span> <a name="typ_bijection"></a>typ_bijection : A.senv -&gt; A.typ -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B.senv -&gt; B.typ -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| typ_bijection_var : forall E E' X,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds X Typ E -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds X Typ E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E (A.typ_fvar X) E' (B.fvar X)<br/>
&nbsp;&nbsp;| typ_bijection_top : forall E E',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E (A.typ_top) E' (B.typ_top)<br/>
&nbsp;&nbsp;| typ_bijection_arrow : forall E E' T1 T1' T2 T2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T1 E' T1' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T2 E' T2' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E (A.typ_arrow T1 T2) E' (B.typ_arrow T1' T2')<br/>
&nbsp;&nbsp;| typ_bijection_all : forall L E E' T1 T1' T2 T2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T1 E' T1' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall X : atom, X `notin` L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection ([(X,Typ)] ++ E)  (A.open_tt T2 X)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(X,Typ)] ++ E') (B.open T2' (B.typ_fvar X))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E (A.typ_all T1 T2) E' (B.typ_all T1' T2')<br/>
&nbsp;&nbsp;| typ_bijection_sum : forall E E' T1 T1' T2 T2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T1 E' T1' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T2 E' T2' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E (A.typ_sum T1 T2) E' (B.typ_sum T1' T2').<br/>

<br/>
<span class="keyword">Hint</span> Constructors typ_bijection.<br/>

<br/>
</code>

<div class="doc">
<a name="lab220"></a><h2 class="section">Properties</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
The relation contains only related environments. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_senv"></a>typ_bijection_senv : forall E E' T1 T2,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve typ_bijection_senv.<br/>

<br/>
</code>

<div class="doc">
The relation contains only well-formed types. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_regular_1"></a>typ_bijection_regular_1 : forall E E' T1 T2,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;A.wf_typ E T1.<br/>

<br/>
<span class="keyword">Hint</span> Resolve typ_bijection_regular_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_regular_2"></a>typ_bijection_regular_2 : forall E E' T1 T2,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;B.wf_typ E' T2.<br/>

<br/>
<span class="keyword">Hint</span> Resolve typ_bijection_regular_2.<br/>

<br/>
</code>

<div class="doc">
The bijection only holds for ok environments. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_ok_1"></a>typ_bijection_ok_1 : forall E T1 E' T2,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;ok E.<br/>

<br/>
<span class="keyword">Hint</span> Resolve typ_bijection_ok_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_ok_2"></a>typ_bijection_ok_2 : forall E E' T1 T2,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;ok E'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve typ_bijection_ok_2.<br/>

<br/>
</code>

<div class="doc">
Define a tactic to simplify proving well-formedness goals. 
</div>
<code>

<br/>
<span class="keyword">Ltac</span> solve_lc_1 := try first [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;solve [apply lc_var]<br/>
&nbsp;&nbsp;| solve [apply type_var]<br/>
&nbsp;&nbsp;| solve [eapply B''.type_from_wf_typ; eapply typ_bijection_regular_2; eauto]<br/>
&nbsp;&nbsp;| solve [eapply A''.type_from_wf_typ; eapply typ_bijection_regular_1; eauto]<br/>
&nbsp;&nbsp;].<br/>

<br/>
</code>

<div class="doc">
Weakening holds for the bijection. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_weakening"></a>typ_bijection_weakening : forall E E' F F' G G' T1 T2,<br/>
&nbsp;&nbsp;typ_bijection (F ++ E) T1 (F' ++ E') T2 -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F' -&gt;<br/>
&nbsp;&nbsp;senv_bijection G G' -&gt;<br/>
&nbsp;&nbsp;ok (F ++ G ++ E) -&gt;<br/>
&nbsp;&nbsp;ok (F' ++ G' ++ E') -&gt;<br/>
&nbsp;&nbsp;typ_bijection (F ++ G ++ E) T1 (F' ++ G' ++ E') T2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_weakening_head"></a>typ_bijection_weakening_head : forall E E' F F' T1 T2,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F' -&gt;<br/>
&nbsp;&nbsp;ok (F ++ E) -&gt;<br/>
&nbsp;&nbsp;ok (F' ++ E') -&gt;<br/>
&nbsp;&nbsp;typ_bijection (F ++ E) T1 (F' ++ E') T2.<br/>

<br/>
<span class="keyword">Hint</span> Resolve typ_bijection_weakening_head.<br/>

<br/>
</code>

<div class="doc">
Substitution commutes with the bijection. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_subst"></a>typ_bijection_subst : forall E E' F F' T1 T2 U1 U2 X,<br/>
&nbsp;&nbsp;typ_bijection (F ++ [(X,Typ)] ++ E) T1 (F' ++ [(X,Typ)] ++ E') T2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection (F ++ E) (A.subst_tt X U1 T1) (F' ++ E') (B.subst X U2 T2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_rename"></a>typ_bijection_rename : forall E E' T1 T2 (X Y : atom),<br/>
&nbsp;&nbsp;X &lt;&gt; Y -&gt;<br/>
&nbsp;&nbsp;X `notin` (A.fv_tt T1 `union` fv_spec Typ T2) -&gt;<br/>
&nbsp;&nbsp;ok ([(Y,Typ)] ++ E) -&gt;<br/>
&nbsp;&nbsp;ok ([(Y,Typ)] ++ E') -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;typ_bijection ([(X,Typ)]++E) (A.open_tt T1 X) ([(X,Typ)]++E') (B.open T2 (B.typ_fvar X)) -&gt;<br/>
&nbsp;&nbsp;typ_bijection ([(Y,Typ)]++E) (A.open_tt T1 Y) ([(Y,Typ)]++E') (B.open T2 (B.typ_fvar Y)).<br/>

<br/>
</code>

<div class="doc">
Now prove that the bijection actually is a bijection. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_total"></a>typ_bijection_total : forall E T1,<br/>
&nbsp;&nbsp;A.wf_typ E T1 -&gt;<br/>
&nbsp;&nbsp;exists E', exists T2, senv_bijection E E' /\ typ_bijection E T1 E' T2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_unique"></a>typ_bijection_unique : forall E E' T1 T2 T3,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T3 -&gt;<br/>
&nbsp;&nbsp;T2 = T3.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_injective"></a>typ_bijection_injective : forall E E' T1 T2 T3,<br/>
&nbsp;&nbsp;typ_bijection E T1 E' T3 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E T2 E' T3 -&gt; T1 = T2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_surjective"></a>typ_bijection_surjective : forall E' T2,<br/>
&nbsp;&nbsp;B.wf_typ E' T2 -&gt;<br/>
&nbsp;&nbsp;exists E, exists T1, senv_bijection E E' /\ typ_bijection E T1 E' T2.<br/>

<br/>
</code>

<div class="doc">
<a name="lab221"></a><h1 class="section">Bijection on expressions</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
We first define a relation on well-formed Fsub expressions and
    then show that the relation defines a bijection on such terms. 
</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab222"></a><h2 class="section">Definition</h2>

</div>
<code>

<br/>
<span class="keyword">Inductive</span> <a name="exp_bijection"></a>exp_bijection : A.senv -&gt; A.exp -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B.senv -&gt; B.exp -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| exp_bijection_var : forall E E' x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds x Exp E -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds x Exp E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_fvar x) E' (B.exp_fvar x)<br/>
&nbsp;&nbsp;| exp_bijection_abs : forall L E E' T T' e e',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T E' T' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection ([(x,Exp)]++E) (A.open_ee e x) ([(x,Exp)]++E') (B.open e' (B.exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_abs T e) E' (B.exp_abs T' e')<br/>
&nbsp;&nbsp;| exp_bijection_app : forall E E' e1 e1' e2 e2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e1 E' e1' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e2 E' e2' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_app e1 e2) E' (B.exp_app e1' e2')<br/>
&nbsp;&nbsp;| exp_bijection_tabs : forall L E E' T T' e e',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T E' T' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall X : atom, X `notin` L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection ([(X,Typ)]++E) (A.open_te e X) ([(X,Typ)]++E') (B.open e' (B.typ_fvar X))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_tabs T e) E' (B.exp_tabs T' e')<br/>
&nbsp;&nbsp;| exp_bijection_tapp : forall E E' e e' T T',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e E' e' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection E T E' T' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_tapp e T) E' (B.exp_tapp e' T')<br/>
&nbsp;&nbsp;| exp_bijection_let : forall L E E' e1 e1' e2 e2',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e1 E' e1' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection ([(x,Exp)]++E) (A.open_ee e2 x) ([(x,Exp)]++E') (B.open e2' (B.exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_let e1 e2) E' (B.exp_let e1' e2')<br/>
&nbsp;&nbsp;| exp_bijection_inl : forall E E' e e',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e E' e' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_inl e) E' (B.exp_inl e')<br/>
&nbsp;&nbsp;| exp_bijection_inr : forall E E' e e',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e E' e' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_inr e) E' (B.exp_inr e')<br/>
&nbsp;&nbsp;| exp_bijection_case : forall L E E' e1 e1' e2 e2' e3 e3',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E e1 E' e1' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection ([(x,Exp)]++E) (A.open_ee e2 x) ([(x,Exp)]++E') (B.open e2' (B.exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall x : atom, x `notin` L -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection ([(x,Exp)]++E) (A.open_ee e3 x) ([(x,Exp)]++E') (B.open e3' (B.exp_fvar x))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp_bijection E (A.exp_case e1 e2 e3) E' (B.exp_case e1' e2' e3').<br/>

<br/>
<span class="keyword">Hint</span> Constructors exp_bijection.<br/>

<br/>
</code>

<div class="doc">
<a name="lab223"></a><h2 class="section">Properties</h2>

</div>
<code>

<br/>
</code>

<div class="doc">
The relation contains only related environments. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_senv"></a>exp_bijection_senv : forall E E' T1 T2,<br/>
&nbsp;&nbsp;exp_bijection E T1 E' T2 -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve exp_bijection_senv.<br/>

<br/>
</code>

<div class="doc">
The relation contains only well-formed expressions. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_regular_1"></a>exp_bijection_regular_1 : forall E E' e1 e2,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e2 -&gt;<br/>
&nbsp;&nbsp;A.wf_exp E e1.<br/>

<br/>
<span class="keyword">Hint</span> Resolve exp_bijection_regular_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_regular_2"></a>exp_bijection_regular_2 : forall E E' e1 e2,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e2 -&gt;<br/>
&nbsp;&nbsp;B.wf_exp E' e2.<br/>

<br/>
<span class="keyword">Hint</span> Resolve exp_bijection_regular_2.<br/>

<br/>
</code>

<div class="doc">
The bijection only holds for ok environments. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_ok_1"></a>exp_bijection_ok_1 : forall E E' e1 e2,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e2 -&gt;<br/>
&nbsp;&nbsp;ok E.<br/>

<br/>
<span class="keyword">Hint</span> Resolve exp_bijection_ok_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_ok_2"></a>exp_bijection_ok_2 : forall E E' e1 e2,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e2 -&gt;<br/>
&nbsp;&nbsp;ok E'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve exp_bijection_ok_2.<br/>

<br/>
</code>

<div class="doc">
Define a tactic to simplify proving well-formedness goals. 
</div>
<code>

<br/>
<span class="keyword">Ltac</span> solve_lc_2 := try first [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;solve [solve_lc_1]<br/>
&nbsp;&nbsp;| solve [apply expr_var]<br/>
&nbsp;&nbsp;| solve [eapply B''.expr_from_wf_exp; eapply exp_bijection_regular_2; eauto]<br/>
&nbsp;&nbsp;| solve [eapply A''.expr_from_wf_exp; eapply exp_bijection_regular_1; eauto]<br/>
&nbsp;&nbsp;].<br/>

<br/>
</code>

<div class="doc">
Weakening holds for the bijection. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_weakening"></a>exp_bijection_weakening : forall E E' F F' G G' e1 e2,<br/>
&nbsp;&nbsp;exp_bijection (F ++ E) e1 (F' ++ E') e2 -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F' -&gt;<br/>
&nbsp;&nbsp;senv_bijection G G' -&gt;<br/>
&nbsp;&nbsp;ok (F ++ G ++ E) -&gt;<br/>
&nbsp;&nbsp;ok (F' ++ G' ++ E') -&gt;<br/>
&nbsp;&nbsp;exp_bijection (F ++ G ++ E) e1 (F' ++ G' ++ E') e2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_weakening_head"></a>exp_bijection_weakening_head : forall E E' F F' e1 e2,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e2 -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F' -&gt;<br/>
&nbsp;&nbsp;ok (F ++ E) -&gt;<br/>
&nbsp;&nbsp;ok (F' ++ E') -&gt;<br/>
&nbsp;&nbsp;exp_bijection (F ++ E) e1 (F' ++ E') e2.<br/>

<br/>
<span class="keyword">Hint</span> Resolve exp_bijection_weakening_head.<br/>

<br/>
</code>

<div class="doc">
Substitution commutes with the bijection. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_strengthening"></a>typ_bijection_strengthening : forall E E' F F' x T1 T2,<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection F F' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (F ++ [(x,Exp)] ++ E) T1 (F' ++ [(x,Exp)] ++ E') T2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection (F ++ E) T1 (F' ++ E') T2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_subst_ee"></a>exp_bijection_subst_ee : forall E E' F F' e1 e2 U1 U2 X,<br/>
&nbsp;&nbsp;exp_bijection (F ++ [(X,Exp)] ++ E) e1 (F' ++ [(X,Exp)] ++ E') e2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection (F ++ E) (A.subst_ee X U1 e1) (F' ++ E') (B.subst X U2 e2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_subst_te"></a>exp_bijection_subst_te : forall E E' F F' e1 e2 U1 U2 X,<br/>
&nbsp;&nbsp;exp_bijection (F ++ [(X,Typ)] ++ E) e1 (F' ++ [(X,Typ)] ++ E') e2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection (F ++ E) (A.subst_te X U1 e1) (F' ++ E') (B.subst X U2 e2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_rename_open_ee"></a>exp_bijection_rename_open_ee : forall E E' e1 e2 (x y : atom),<br/>
&nbsp;&nbsp;x &lt;&gt; y -&gt;<br/>
&nbsp;&nbsp;x `notin` (A.fv_ee e1 `union` fv_spec Exp e2) -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;ok ([(y,Exp)]++E) -&gt;<br/>
&nbsp;&nbsp;ok ([(y,Exp)]++E') -&gt;<br/>
&nbsp;&nbsp;exp_bijection ([(x,Exp)]++E) (A.open_ee e1 x) ([(x,Exp)]++E') (B.open e2 (B.exp_fvar x)) -&gt;<br/>
&nbsp;&nbsp;exp_bijection ([(y,Exp)]++E) (A.open_ee e1 y) ([(y,Exp)]++E') (B.open e2 (B.exp_fvar y)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_rename_open_te"></a>exp_bijection_rename_open_te : forall E E' e1 e2 (x y : atom),<br/>
&nbsp;&nbsp;x &lt;&gt; y -&gt;<br/>
&nbsp;&nbsp;x `notin` (A.fv_te e1 `union` fv_spec Typ e2) -&gt;<br/>
&nbsp;&nbsp;senv_bijection E E' -&gt;<br/>
&nbsp;&nbsp;ok ([(y,Typ)]++E) -&gt;<br/>
&nbsp;&nbsp;ok ([(y,Typ)]++E') -&gt;<br/>
&nbsp;&nbsp;exp_bijection ([(x,Typ)]++E) (A.open_te e1 x) ([(x,Typ)]++E') (B.open e2 (B.typ_fvar x)) -&gt;<br/>
&nbsp;&nbsp;exp_bijection ([(y,Typ)]++E) (A.open_te e1 y) ([(y,Typ)]++E') (B.open e2 (B.typ_fvar y)).<br/>

<br/>
</code>

<div class="doc">
Now prove that the bijection actually is a bijection. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_total"></a>exp_bijection_total : forall E e,<br/>
&nbsp;&nbsp;A.wf_exp E e -&gt;<br/>
&nbsp;&nbsp;exists E', exists e', senv_bijection E E' /\ exp_bijection E e E' e'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_unique"></a>exp_bijection_unique : forall E E' e1 e2 e3,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e3 -&gt;<br/>
&nbsp;&nbsp;e2 = e3.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_injective"></a>exp_bijection_injective : forall E E' e1 e2 e3,<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e3 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e2 E' e3 -&gt;<br/>
&nbsp;&nbsp;e1 = e2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_surjective"></a>exp_bijection_surjective : forall E' e2,<br/>
&nbsp;&nbsp;B.wf_exp E' e2 -&gt;<br/>
&nbsp;&nbsp;exists E, exists e1, senv_bijection E E' /\ exp_bijection E e1 E' e2.<br/>

<br/>
</code>

<div class="doc">
<a name="lab224"></a><h1 class="section">Bijection on environments</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
<a name="lab225"></a><h2 class="section">Definition</h2>

</div>
<code>

<br/>
<span class="keyword">Inductive</span> <a name="env_bijection"></a>env_bijection : A.env -&gt; B.env -&gt; <span class="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| env_bijection_nil :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env_bijection nil nil<br/>
&nbsp;&nbsp;| env_bijection_typ : forall E E' x T T',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x `notin` (dom E `union` dom E') -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection (A.to_senv E) T (B.to_senv E') T' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env_bijection ([(x, A.bind_typ T)] ++ E) ([(x, B.bind_typ T')] ++ E')<br/>
&nbsp;&nbsp;| env_bijection_sub : forall E E' X T T',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X `notin` (dom E `union` dom E') -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typ_bijection (A.to_senv E) T (B.to_senv E') T' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env_bijection ([(X, A.bind_sub T)] ++ E) ([(X, B.bind_sub T')] ++ E').<br/>

<br/>
</code>

<div class="doc">
<a name="lab226"></a><h2 class="section">Properties</h2>

</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_senv"></a>env_bijection_senv : forall E E',<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;senv_bijection (A.to_senv E) (B.to_senv E').<br/>

<br/>
<span class="keyword">Hint</span> Resolve env_bijection_senv.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_binds_sub_1"></a>env_bijection_binds_sub_1 : forall E E' X U,<br/>
&nbsp;&nbsp;binds X (A.bind_sub U) E -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;exists U', typ_bijection (A.to_senv E) U (B.to_senv E') U' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds X (B.bind_sub U') E'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_binds_sub_2"></a>env_bijection_binds_sub_2 : forall E' E X U',<br/>
&nbsp;&nbsp;binds X (B.bind_sub U') E' -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;exists U, typ_bijection (A.to_senv E) U (B.to_senv E') U' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds X (A.bind_sub U) E.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_binds_typ_1"></a>env_bijection_binds_typ_1 : forall E E' X U,<br/>
&nbsp;&nbsp;binds X (A.bind_typ U) E -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;exists U', typ_bijection (A.to_senv E) U (B.to_senv E') U' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds X (B.bind_typ U') E'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_binds_typ_2"></a>env_bijection_binds_typ_2 : forall E' E X U',<br/>
&nbsp;&nbsp;binds X (B.bind_typ U') E' -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;exists U, typ_bijection (A.to_senv E) U (B.to_senv E') U' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds X (A.bind_typ U) E.<br/>

<br/>
</code>

<div class="doc">
The relation holds for only well-formed environments. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_wf_env_1"></a>env_bijection_wf_env_1 : forall E E',<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;A.wf_env E.<br/>

<br/>
<span class="keyword">Hint</span> Resolve env_bijection_wf_env_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="env_bijection_wf_env_2"></a>env_bijection_wf_env_2 : forall E E',<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;B.wf_env E'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve env_bijection_wf_env_2.<br/>

<br/>
</code>

<div class="doc">
<a name="lab227"></a><h1 class="section">Relations derive the same judgements</h1>

</div>
<code>

<br/>
</code>

<div class="doc">
These first lemmas are trivial, given our definitions. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="wf_typ_bijection"></a>wf_typ_bijection : forall E E' T T',<br/>
&nbsp;&nbsp;typ_bijection E T E' T' -&gt;<br/>
&nbsp;&nbsp;(A.wf_typ E T &lt;-&gt; B.wf_typ E' T').<br/>

<br/>
<span class="keyword">Lemma</span> <a name="wf_exp_bijection"></a>wf_exp_bijection : forall E E' e e',<br/>
&nbsp;&nbsp;exp_bijection E e E' e' -&gt;<br/>
&nbsp;&nbsp;(A.wf_exp E e &lt;-&gt; B.wf_exp E' e').<br/>

<br/>
<span class="keyword">Lemma</span> <a name="wf_env_bijection"></a>wf_env_bijection : forall E E',<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;(A.wf_env E &lt;-&gt; B.wf_env E').<br/>

<br/>
</code>

<div class="doc">
We need a few corollaries of the substitution lemmas for
    the bijections. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_subst_head"></a>typ_bijection_subst_head : forall E E' T1 T2 U1 U2 X,<br/>
&nbsp;&nbsp;typ_bijection ([(X,Typ)] ++ E) T1 ([(X,Typ)] ++ E') T2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E (A.subst_tt X U1 T1) E' (B.subst X U2 T2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typ_bijection_subst_head_open"></a>typ_bijection_subst_head_open : forall E E' T1 T2 U1 U2 X,<br/>
&nbsp;&nbsp;X `notin` (A.fv_tt T1 `union` fv_spec Typ T2) -&gt;<br/>
&nbsp;&nbsp;typ_bijection ([(X,Typ)] ++ E) (A.open_tt T1 X) ([(X,Typ)] ++ E') (B.open T2 (B.typ_fvar X)) -&gt;<br/>
&nbsp;&nbsp;typ_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E (A.open_tt T1 U1) E' (B.open T2 U2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_subst_ee_head"></a>exp_bijection_subst_ee_head : forall E E' e1 e2 U1 U2 X,<br/>
&nbsp;&nbsp;exp_bijection ([(X,Exp)] ++ E) e1 ([(X,Exp)] ++ E') e2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E (A.subst_ee X U1 e1) E' (B.subst X U2 e2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_subst_ee_head_open"></a>exp_bijection_subst_ee_head_open : forall E E' e1 e2 U1 U2 X,<br/>
&nbsp;&nbsp;X `notin` (A.fv_ee e1 `union` fv_spec Exp e2) -&gt;<br/>
&nbsp;&nbsp;exp_bijection ([(X,Exp)] ++ E) (A.open_ee e1 X) ([(X,Exp)] ++ E') (B.open e2 (B.exp_fvar X)) -&gt;<br/>
&nbsp;&nbsp;exp_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E (A.open_ee e1 U1) E' (B.open e2 U2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_subst_te_head"></a>exp_bijection_subst_te_head : forall E E' e1 e2 U1 U2 X,<br/>
&nbsp;&nbsp;exp_bijection ([(X,Typ)] ++ E) e1 ([(X,Typ)] ++ E') e2 -&gt;<br/>
&nbsp;&nbsp;typ_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E (A.subst_te X U1 e1) E' (B.subst X U2 e2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exp_bijection_subst_te_head_open"></a>exp_bijection_subst_te_head_open : forall E E' e1 e2 U1 U2 X,<br/>
&nbsp;&nbsp;X `notin` (A.fv_te e1 `union` fv_spec Typ e2) -&gt;<br/>
&nbsp;&nbsp;exp_bijection ([(X,Typ)] ++ E) (A.open_te e1 X) ([(X,Typ)] ++ E') (B.open e2 (B.typ_fvar X)) -&gt;<br/>
&nbsp;&nbsp;typ_bijection E U1 E' U2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E (A.open_te e1 U1) E' (B.open e2 U2).<br/>

<br/>
</code>

<div class="doc">
We now prove that the main Fsub relations derive the same sets of
    judgements. 
</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="sub_bijection_1"></a>sub_bijection_1 : forall E E' T T' S S',<br/>
&nbsp;&nbsp;A.sub E S T -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (A.to_senv E) S (B.to_senv E') S' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (A.to_senv E) T (B.to_senv E') T' -&gt;<br/>
&nbsp;&nbsp;B.sub E' S' T'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve sub_bijection_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="sub_bijection_2"></a>sub_bijection_2 : forall E E' T T' S S',<br/>
&nbsp;&nbsp;B.sub E' S' T' -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (A.to_senv E) S (B.to_senv E') S' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (A.to_senv E) T (B.to_senv E') T' -&gt;<br/>
&nbsp;&nbsp;A.sub E S T.<br/>

<br/>
<span class="keyword">Hint</span> Resolve sub_bijection_2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typing_bijection_1"></a>typing_bijection_1 : forall E E' e e' T T',<br/>
&nbsp;&nbsp;A.typing E e T -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;exp_bijection (A.to_senv E) e (B.to_senv E') e' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (A.to_senv E) T (B.to_senv E') T' -&gt;<br/>
&nbsp;&nbsp;B.typing E' e' T'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="typing_bijection_2"></a>typing_bijection_2 : forall E E' e e' T T',<br/>
&nbsp;&nbsp;B.typing E' e' T' -&gt;<br/>
&nbsp;&nbsp;env_bijection E E' -&gt;<br/>
&nbsp;&nbsp;exp_bijection (A.to_senv E) e (B.to_senv E') e' -&gt;<br/>
&nbsp;&nbsp;typ_bijection (A.to_senv E) T (B.to_senv E') T' -&gt;<br/>
&nbsp;&nbsp;A.typing E e T.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="value_bijection_1"></a>value_bijection_1 : forall E E' e e',<br/>
&nbsp;&nbsp;A.value e -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e E' e' -&gt;<br/>
&nbsp;&nbsp;B.value e'.<br/>

<br/>
<span class="keyword">Hint</span> Resolve value_bijection_1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="value_bijection_2"></a>value_bijection_2 : forall E E' e e',<br/>
&nbsp;&nbsp;B.value e' -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e E' e' -&gt;<br/>
&nbsp;&nbsp;A.value e.<br/>

<br/>
<span class="keyword">Hint</span> Resolve value_bijection_2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="red_bijection_1"></a>red_bijection_1 : forall E E' e1 e1' e2 e2',<br/>
&nbsp;&nbsp;A.red e1 e2 -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e1' -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e2 E' e2' -&gt;<br/>
&nbsp;&nbsp;B.red e1' e2'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="red_bijection_2"></a>red_bijection_2 : forall E E' e1 e1' e2 e2',<br/>
&nbsp;&nbsp;B.red e1' e2' -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e1 E' e1' -&gt;<br/>
&nbsp;&nbsp;exp_bijection E e2 E' e2' -&gt;<br/>
&nbsp;&nbsp;A.red e1 e2.<br/>
</code>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr">coqdoc</a>
</div>

</div>

</body>
</html>