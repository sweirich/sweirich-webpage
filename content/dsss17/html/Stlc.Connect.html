<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Stlc.Connect</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Stlc.Connect</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Connecting nominal and LN semantics</h1>

<div class="paragraph"> </div>

 Our final goal is to show that the abstract nominal machine implements the
    same semantics as the LN substitution-based small step relation.

<div class="paragraph"> </div>

    We'll do this by proving that any time the abstract machine takes a step,
    we can decode the machine configuration before and after to LN
    expressions, and those expressions are either identical or related by the
    LN step relation.   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Metalib.Metatheory</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Definitions.html#"><span class="id" title="library">Stlc.Definitions</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Lemmas.html#"><span class="id" title="library">Stlc.Lemmas</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Nominal.html#"><span class="id" title="library">Stlc.Nominal</span></a>.<br/>

<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">StlcNotations</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Translating nominal to LN terms</h1>

<div class="paragraph"> </div>

 We translate named terms to LN terms through the use of the
    <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a></span> function. This function replaces all occurrences
    of the given atom by the appropriate bound variable.

<div class="paragraph"> </div>

    This function is defined in the <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#"><span class="id" title="library">Stlc.Lemmas</span></a></span> module and can be
    automatically generated by LNgen.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<span class="id" title="var">ne</span> : <a class="idref" href="Stlc.Nominal.html#n_exp"><span class="id" title="inductive">n_exp</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#ne"><span class="id" title="variable">ne</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_var"><span class="id" title="constructor">n_var</span></a> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_app"><span class="id" title="constructor">n_app</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_abs"><span class="id" title="constructor">n_abs</span></a> <span class="id" title="var">x</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e1</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We also define a translation from machine configurations to LN
    terms. In this case we must substitute all definitions in the
    heap through the terms and create all of the applications in
    the stack. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="apply_heap"><span class="id" title="definition">apply_heap</span></a> (<span class="id" title="var">h</span> : <a class="idref" href="Stlc.Nominal.html#heap"><span class="id" title="definition">heap</span></a>) (<span class="id" title="var">e</span> : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>  :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">e'</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">h'</span> ⇒ <a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <span class="id" title="var">h'</span> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e'</span><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="apply_stack"><span class="id" title="definition">apply_stack</span></a> <span class="id" title="var">h</span> (<span class="id" title="var">s</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Stlc.Nominal.html#frame"><span class="id" title="inductive">frame</span></a>) (<span class="id" title="var">e</span> :<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_app2"><span class="id" title="constructor">n_app2</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">s'</span> ⇒ <a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="var">s'</span> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e'</span>)))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="decode"><span class="id" title="definition">decode</span></a> (<span class="id" title="var">c</span>:<a class="idref" href="Stlc.Nominal.html#configuration"><span class="id" title="definition">configuration</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>  :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">h</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><span class="id" title="var">e</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> ⇒ <a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <span class="id" title="var">h</span> <span class="id" title="var">s</span> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">Demo: connecting free variable functions.</h1>

<div class="paragraph"> </div>

 Here is the first result about our decoding: that the two free
    variable functions agree.

<div class="paragraph"> </div>

    In this part of the file, we will take advantage of automation
    provided by the Lemmas module. In particular, this module defines a
    database of rewriting hints (called <span class="inlinecode"><span class="id" title="var">lngen</span></span>) that can be used to
    automatically rewrite LN terms into simpler form. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#fv_nom"><span class="id" title="definition">fv_nom</span></a> <a class="idref" href="Stlc.Connect.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">[=]</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>; <span class="id" title="var">fsetdec</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can also extend the hint database with new rewritings. 
</div>
<div class="code">
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a> : <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">fv_nom_fv_exp_eq</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
The Metatheory library contains two powerful tactics for simplifying
    goals:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">default_steps</span></span>: repeat a bunch of simplifying steps, such as
       simplifying the goal, inverting simple hypotheses, etc.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" title="var">default_simp</span></span>: above plus case analysis for booleans and other sums

</li>
</ul>

<div class="paragraph"> </div>

    Below, we modify he behavior of these tactics by updating the following
    two definitions, so that the lngen hint databases will be available.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">default_auto</span>        ::= <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">default_autorewrite</span> ::= <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Next, we show that our decoding of nominal terms and
    configurations produces locally closed LN terms.

<div class="paragraph"> </div>

    Again, these proofs are highly automatable.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="nom_to_exp_lc"><span class="id" title="lemma">nom_to_exp_lc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span>, <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">default_steps</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">nom_to_exp_lc</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_lc"><span class="id" title="lemma">apply_heap_lc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">apply_heap_lc</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
Exercise: apply_stack_lc

<div class="paragraph"> </div>

    State and prove a lemma called <span class="inlinecode"><span class="id" title="var">apply_stack_lc</span></span> and add it to the
    <span class="inlinecode"><span class="id" title="var">lngen</span></span> hint database so that the proof for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#decode_lc"><span class="id" title="lemma">decode_lc</span></a></span> goes
    through. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="decode_lc"><span class="id" title="lemma">decode_lc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span>, <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="Stlc.Connect.html#c"><span class="id" title="variable">c</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [[<span class="id" title="var">h</span> <span class="id" title="var">e</span>] <span class="id" title="var">s</span>]; <span class="id" title="var">default_simp</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Properties of apply_heap 
<div class="paragraph"> </div>

 Since the heap is just an iterated substitution, it inherits
    properties from <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">alist</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span> is a tactic from the metatheory library for
    induction over association lists (such as the heap).

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_abs"><span class="id" title="lemma">apply_heap_abs</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_abs"><span class="id" title="lemma">apply_heap_abs</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_app"><span class="id" title="lemma">apply_heap_app</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Connect.html#e2"><span class="id" title="variable">e2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e2"><span class="id" title="variable">e2</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_app"><span class="id" title="lemma">apply_heap_app</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
Exercise: apply_heap_open

<div class="paragraph"> </div>

    This function is the <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a></span> analogue to
    <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a></span>, commuting the heap-based
    substitution with the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a></span> operation.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_open"><span class="id" title="lemma">apply_heap_open</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">e0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a>)  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_open"><span class="id" title="lemma">apply_heap_open</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
This last lemma "unsimpl"s the <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a></span> function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="combine"><span class="id" title="lemma">combine</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a>) <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h1 class="section">Stacks as evaluation contexts</h1>

<div class="paragraph"> </div>

 Here is a quick lemma that uses the properties defined above.
    It shows that the stack does behave like an evaluation context,
    lifting a small-step reduction to a larger term.

<div class="paragraph"> </div>

    Q: Which properties above does this proof implicitly rely on?
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_stack_cong"><span class="id" title="lemma">apply_stack_cong</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h1 class="section">Scoped heaps</h1>

<div class="paragraph"> </div>

 Next, we define when a heap is *well-scoped*.  Well-scoped heaps
    behave "telescopically".  Each binding (x,e) added to the heap is for
    a unique name x and the free variables of e are bound in the
    remainder of the heap.

<div class="paragraph"> </div>

    The scoping relation is parameterized by <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a></span>, an "ambient
    scope". This will let us reason about the execution of the abstract
    machine for non-closed lambda terms. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> (<span class="id" title="var">D</span> : <span class="id" title="abbreviation">atoms</span>) : <a class="idref" href="Stlc.Nominal.html#heap"><span class="id" title="definition">heap</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="scoped_nil"><span class="id" title="constructor">scoped_nil</span></a>  : <a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <span class="id" title="var">D</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;| <a name="scoped_cons"><span class="id" title="constructor">scoped_cons</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="var">D</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="var">D</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <span class="id" title="var">D</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <span class="id" title="var">D</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a>).<br/>

<br/>
</div>

<div class="doc">
Exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap_get"><span class="id" title="lemma">apply_heap_get</span></a></span>  (recommended)

<div class="paragraph"> </div>

    We can use get to look up expressions in the heap. However, to know that
    we have the right result we need to know that the heap is well-scoped, i.e.
    that later bindings do not affect earlier ones.

<div class="paragraph"> </div>

    State a lemma about the scoping of expressions that appear in the heap
    and use it to finish the apply_heap_get below.
 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_get"><span class="id" title="lemma">apply_heap_get</span></a> :  <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">D</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">get</span> <a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="tactic">intros</span>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "x is at the current heap location".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="tactic">auto</span>. <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "x is later in the heap".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="tactic">auto</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h1 class="section">Scoped stacks</h1>

<div class="paragraph"> </div>

 We also care about the free variables that can appear in stacks. (We
    will use this definition to define when configurations are
    well-scoped below.)  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="fv_stack"><span class="id" title="definition">fv_stack</span></a> <span class="id" title="var">s</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <span class="id" title="notation">{}</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_app2"><span class="id" title="constructor">n_app2</span></a> <span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e</span>) <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#fv_stack"><span class="id" title="definition">fv_stack</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Stacks that are well-scoped can discard irrelevant bindings
    from the heap. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_stack_fresh_eq"><span class="id" title="lemma">apply_stack_fresh_eq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">x</span> <span class="id" title="var">e1</span> <span class="id" title="var">h</span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Connect.html#fv_stack"><span class="id" title="definition">fv_stack</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a>) <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHs</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab7"></a><h1 class="section">Connecting "freshening"</h1>

<div class="paragraph"> </div>

 The abstract machine uses the nominal <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a></span> operation to make sure
    that the variables in abstractions are "fresh".  To be able prove that
    this machine implements the step relation for LN terms, we need to
    connect this operation to a LN version of "freshening".

<div class="paragraph"> </div>

    The <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a></span> lemma below states that connection. If a variable <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a></span>
    is "fresh", then substituting with it (in the LN representation) is the
    same as swapping with it (in the nominal representation).

<div class="paragraph"> </div>

<pre>
Lemma swap_spec : forall  n w y,
    y `notin` fv_exp (nom_to_exp n) -&gt;
    w &lt;&gt; y -&gt;
    [w ~&gt; var_f y] (nom_to_exp n) =
    nom_to_exp (swap w y n).
</pre>

<div class="paragraph"> </div>

 
<div class="paragraph"> </div>

 This proof depends on the following auxiliary lemma about the
    close operation --- that we can equivalently rename the atom that
    we are closing with. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a> <a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> 0 <span class="id" title="keyword">as</span> <span class="id" title="var">k</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">e</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Nominal.html#swap_size_eq"><span class="id" title="lemma">swap_size_eq</span></a> : <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">le_S_n</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
One difficulty of <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a></span> is that we cannot do induction on
    the structure of nominal terms. Instead, we must use a size
    based instead. That way, we will be able to call the IH on subterms
    that have had their variables swapped. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="swap_spec_aux"><span class="id" title="lemma">swap_spec_aux</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">t</span> <span class="id" title="var">w</span> <span class="id" title="var">y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#size"><span class="id" title="definition">size</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9b077c369e19739ef880736ba34623ff"><span class="id" title="notation">≤</span></a> <a class="idref" href="Stlc.Connect.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">t</span> <span class="id" title="var">w</span> <span class="id" title="var">y</span> <span class="id" title="var">SZ</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Nominal.html#swap_var"><span class="id" title="definition">swap_var</span></a>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Nominal.html#swap_var"><span class="id" title="definition">swap_var</span></a>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a> <span class="id" title="var">w</span> <span class="id" title="var">y</span>); <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="var">default_simp</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">z</span> <span class="id" title="keyword">for</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">t</span>) <span class="id" title="notation">\</span><span class="id" title="notation">u</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a> <span class="id" title="var">w</span> <span class="id" title="var">y</span> <span class="id" title="var">t</span>)) <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="notation">{{</span><span class="id" title="var">w</span><span class="id" title="notation">}}</span> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="notation">{{</span><span class="id" title="var">y</span><span class="id" title="notation">}}</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a> <span class="id" title="var">y</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a> <span class="id" title="var">w</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_close_exp_wrt_exp"><span class="id" title="lemma">subst_exp_close_exp_wrt_exp</span></a>; <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="var">default_steps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="var">default_steps</span>. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="var">default_steps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Nominal.html#shuffle_swap"><span class="id" title="lemma">shuffle_swap</span></a>; <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Stlc.Connect.html#fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Nominal.html#fv_nom_swap"><span class="id" title="lemma">fv_nom_swap</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm</span>; <span class="id" title="var">default_steps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="swap_spec"><span class="id" title="lemma">swap_spec</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> <span class="id" title="var">w</span> <span class="id" title="var">y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Connect.html#swap_spec_aux"><span class="id" title="lemma">swap_spec_aux</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">t</span>:=<span class="id" title="var">t</span>)(<span class="id" title="var">m</span>:=<a class="idref" href="Stlc.Nominal.html#size"><span class="id" title="definition">size</span></a> <span class="id" title="var">t</span>); <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h1 class="section">Connection for alpha-equivalence</h1>

<div class="paragraph"> </div>

 Challenge Exercise: aeq iff =

<div class="paragraph"> </div>

    Show that alpha-equivalence for the nominal representation is definitional
    equality for LN terms.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="aeq_nom_to_exp"><span class="id" title="lemma">aeq_nom_to_exp</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>, <a class="idref" href="Stlc.Nominal.html#aeq"><span class="id" title="inductive">aeq</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="nom_to_exp_eq_aeq"><span class="id" title="lemma">nom_to_exp_eq_aeq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>, <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Nominal.html#aeq"><span class="id" title="inductive">aeq</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab9"></a><h1 class="section">SIMULATION</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> : <span class="id" title="abbreviation">atoms</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Nominal.html#configuration"><span class="id" title="definition">configuration</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="scoped_conf_witness"><span class="id" title="constructor">scoped_conf_witness</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#fv_stack"><span class="id" title="definition">fv_stack</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simulate_step"><span class="id" title="lemma">simulate_step</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">h'</span> <span class="id" title="var">e'</span> <span class="id" title="var">s'</span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#TakeStep"><span class="id" title="constructor">TakeStep</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h'"><span class="id" title="variable">h'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h'"><span class="id" title="variable">h'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>) (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h'"><span class="id" title="variable">h'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">h'</span> <span class="id" title="var">e'</span> <span class="id" title="var">s'</span> <span class="id" title="var">STEP</span> <span class="id" title="var">SCOPE</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">SCOPE</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">SCOPE</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="Stlc.Nominal.html#isVal"><span class="id" title="definition">isVal</span></a> <span class="id" title="var">e</span>) <span class="id" title="var">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">f</span> <span class="id" title="var">eqn</span>:?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span> <span class="id" title="var">eqn</span>:?; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="lemma">AtomSetProperties.In_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="lemma">atom_fresh</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">STEP</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#combine"><span class="id" title="lemma">combine</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_stack_fresh_eq"><span class="id" title="lemma">apply_stack_fresh_eq</span></a>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Connect.html#apply_stack_cong"><span class="id" title="lemma">apply_stack_cong</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <span class="id" title="var">x0</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Lemmas.html#subst_exp_spec"><span class="id" title="lemma">subst_exp_spec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>; <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Definitions.html#step_beta"><span class="id" title="constructor">step_beta</span></a>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Stlc.Connect.html#apply_heap_abs"><span class="id" title="lemma">apply_heap_abs</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Connect.html#apply_heap_lc"><span class="id" title="lemma">apply_heap_lc</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H4</span>. <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span> <span class="id" title="var">eqn</span>:?; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="definition">get</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>) <span class="id" title="var">eqn</span>:?; <span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">STEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Connect.html#apply_heap_get"><span class="id" title="axiom">apply_heap_get</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">D</span>:= <span class="id" title="var">D</span>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">STEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_app"><span class="id" title="lemma">apply_heap_app</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#simulate_done"><span class="id" title="lemma">simulate_done</span></a></span>

<div class="paragraph"> </div>

    Show that if the machine says <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#Done"><span class="id" title="constructor">Done</span></a></span> then the LN term is a value.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simulate_done"><span class="id" title="lemma">simulate_done</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> (<span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#Done"><span class="id" title="constructor">Done</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#is_value"><span class="id" title="definition">is_value</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.  <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Challenge exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#simulate_error"><span class="id" title="lemma">simulate_error</span></a></span>

<div class="paragraph"> </div>

    Show that if the machine produces an error, the small step relation
    is stuck.

<div class="paragraph"> </div>

    This is a challenge exercise because you will need to figure out
    at least one nontrivial auxiliary lemma.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simulate_error"><span class="id" title="lemma">simulate_error</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> (<span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#Error"><span class="id" title="constructor">Error</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">∃</span></a> <span class="id" title="var">e0</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>) <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Challenge exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#machine_is_scoped"><span class="id" title="lemma">machine_is_scoped</span></a></span>

<div class="paragraph"> </div>

    Show that the abstract machine is scoped, then any resulting
    configurations are also scoped. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="machine_is_scoped"><span class="id" title="lemma">machine_is_scoped</span></a>: <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">conf'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> (<span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#TakeStep"><span class="id" title="constructor">TakeStep</span></a> <span class="id" title="var">_</span> <a class="idref" href="Stlc.Connect.html#conf'"><span class="id" title="variable">conf'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="Stlc.Connect.html#conf'"><span class="id" title="variable">conf'</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>