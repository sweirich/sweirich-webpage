<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Stlc.Connect</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Stlc.Connect</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Connecting nominal and LN semantics</h1>

<div class="paragraph"> </div>

 Our final goal is to show that the abstract nominal machine implements the
    same semantics as the LN substitution-based small step relation.

<div class="paragraph"> </div>

    We'll do this by proving that any time the abstract machine takes a step,
    we can decode the machine configuration before and after the step to LN
    expressions, and those expressions are either identical or related by the
    LN step relation.

<div class="paragraph"> </div>

<pre>
                    machine_step
             (h,t,s)  ------&gt;  (h',t',s')            nominal terms
                |                  |
                | decode           | decode
                v                  v
                e       - - -&gt;     e'           locally nameless terms
                      step e e'
                         or
                        e = e'
</pre>

<div class="paragraph"> </div>

    This result is the <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#simulate_step"><span class="id" title="lemma">simulate_step</span></a></span> lemma near the end of this file.

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Metalib.Metatheory</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Definitions.html#"><span class="id" title="library">Stlc.Definitions</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Lemmas.html#"><span class="id" title="library">Stlc.Lemmas</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Nominal.html#"><span class="id" title="library">Stlc.Nominal</span></a>.<br/>

<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">StlcNotations</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h2 class="section">Translating nominal terms to LN terms</h2>

<div class="paragraph"> </div>

 We decode named terms to LN terms through the use of the
    <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a></span> function. This function replaces all occurrences of
    a given atom by a new bound variable.

<div class="paragraph"> </div>

    This function is defined in the <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#"><span class="id" title="library">Stlc.Lemmas</span></a></span> module and can be
    automatically generated by LNgen.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<span class="id" title="var">ne</span> : <a class="idref" href="Stlc.Nominal.html#n_exp"><span class="id" title="inductive">n_exp</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#ne"><span class="id" title="variable">ne</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_var"><span class="id" title="constructor">n_var</span></a> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_app"><span class="id" title="constructor">n_app</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_abs"><span class="id" title="constructor">n_abs</span></a> <span class="id" title="var">x</span> <span class="id" title="var">e1</span> ⇒ <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e1</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We also define a translation from machine configurations to LN
    terms. In this case we must substitute all definitions in the
    heap through the terms and create all of the applications in
    the stack. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="apply_heap"><span class="id" title="definition">apply_heap</span></a> (<span class="id" title="var">h</span> : <a class="idref" href="Stlc.Nominal.html#heap"><span class="id" title="definition">heap</span></a>) (<span class="id" title="var">e</span> : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>  :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">e'</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">h'</span> ⇒ <a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <span class="id" title="var">h'</span> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e'</span><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="apply_stack"><span class="id" title="definition">apply_stack</span></a> <span class="id" title="var">h</span> (<span class="id" title="var">s</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Stlc.Nominal.html#frame"><span class="id" title="inductive">frame</span></a>) (<span class="id" title="var">e</span> :<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_app2"><span class="id" title="constructor">n_app2</span></a> <span class="id" title="var">e'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">s'</span> ⇒ <a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="var">s'</span> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e'</span>)))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The full decode function puts all of these parts together. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="decode"><span class="id" title="definition">decode</span></a> (<span class="id" title="var">c</span>:<a class="idref" href="Stlc.Nominal.html#configuration"><span class="id" title="definition">configuration</span></a>) : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>  :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#c"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">h</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><span class="id" title="var">e</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> ⇒ <a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <span class="id" title="var">h</span> <span class="id" title="var">s</span> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Here's an example translation from the machine step demo. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="conf1"><span class="id" title="definition">conf1</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="notation">[</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Nominal.html#Y"><span class="id" title="abbreviation">Y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Nominal.html#n_var"><span class="id" title="constructor">n_var</span></a> <a class="idref" href="Stlc.Nominal.html#Z"><span class="id" title="abbreviation">Z</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><span class="id" title="notation">]</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="Stlc.Nominal.html#n_abs"><span class="id" title="constructor">n_abs</span></a> <a class="idref" href="Stlc.Nominal.html#X"><span class="id" title="abbreviation">X</span></a> (<a class="idref" href="Stlc.Nominal.html#n_var"><span class="id" title="constructor">n_var</span></a> <a class="idref" href="Stlc.Nominal.html#X"><span class="id" title="abbreviation">X</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="notation">[</span><a class="idref" href="Stlc.Nominal.html#n_app2"><span class="id" title="constructor">n_app2</span></a> (<a class="idref" href="Stlc.Nominal.html#n_var"><span class="id" title="constructor">n_var</span></a> <a class="idref" href="Stlc.Nominal.html#Y"><span class="id" title="abbreviation">Y</span></a>)<span class="id" title="notation">]</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <a name="decode1"><span class="id" title="definition">decode1</span></a> : <a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="Stlc.Connect.html#conf1"><span class="id" title="definition">conf1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0)) (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Nominal.html#Z"><span class="id" title="abbreviation">Z</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. &nbsp;&nbsp;<span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab3"></a><h2 class="section">Connecting free variable functions.</h2>

<div class="paragraph"> </div>

 Here is the first result about our decoding: that the two free
    variable functions agree.

<div class="paragraph"> </div>

    In this part of the file, we will take advantage of automation
    provided by the Lemmas module. In particular, this module defines a
    database of rewriting hints (called <span class="inlinecode"><span class="id" title="var">lngen</span></span>) that can be used to
    automatically rewrite LN terms into simpler form. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#fv_nom"><span class="id" title="definition">fv_nom</span></a> <a class="idref" href="Stlc.Connect.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">[=]</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>; <span class="id" title="var">fsetdec</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As we prove new lemmas, we can also extend the hint database with new
    rewritings. 
</div>
<div class="code">
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a> : <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">fv_nom_fv_exp_eq</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
The Metatheory library contains two powerful tactics for simplifying
    goals:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">default_steps</span></span>: repeat a bunch of simplifying steps, such as
       simplifying the goal, inverting simple hypotheses, etc.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" title="var">default_simp</span></span>: above plus case analysis for booleans and other sums

</li>
</ul>

<div class="paragraph"> </div>

    Below, we modify the behavior of these tactics by updating the following
    two definitions, so that the <span class="inlinecode"><span class="id" title="var">lngen</span></span> hint databases will be available.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">default_auto</span>        ::= <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">default_autorewrite</span> ::= <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
We also add a few more rewriting lemmas to the hint database to
    automate our proofs. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a> : <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Nominal.html#swap_size_eq"><span class="id" title="lemma">swap_size_eq</span></a> : <span class="id" title="var">lngen</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">le_S_n</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h2 class="section">Decoded terms are locally closed</h2>

<div class="paragraph"> </div>

 Next, we show that our decoding of nominal terms and
    configurations produces locally closed LN terms.

<div class="paragraph"> </div>

    Again, these proofs are highly automatable.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="nom_to_exp_lc"><span class="id" title="lemma">nom_to_exp_lc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span>, <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">default_steps</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">nom_to_exp_lc</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_lc"><span class="id" title="lemma">apply_heap_lc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">apply_heap_lc</span> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h3 class="section">Exercise: <span class="inlinecode"><span class="id" title="var">apply_stack_lc</span></span></h3>


<div class="paragraph"> </div>

    State and prove a lemma called <span class="inlinecode"><span class="id" title="var">apply_stack_lc</span></span> and add it to the
    <span class="inlinecode"><span class="id" title="var">lngen</span></span> hint database so that the proof for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#decode_lc"><span class="id" title="lemma">decode_lc</span></a></span> goes
    through. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="decode_lc"><span class="id" title="lemma">decode_lc</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">c</span>, <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="Stlc.Connect.html#c"><span class="id" title="variable">c</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [[<span class="id" title="var">h</span> <span class="id" title="var">e</span>] <span class="id" title="var">s</span>]; <span class="id" title="var">default_simp</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h2 class="section">Properties of apply_heap</h2>

<div class="paragraph"> </div>

 Since the heap is just an iterated substitution, it inherits
    properties from <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a></span>.

<div class="paragraph"> </div>

    Below, <span class="inlinecode"><span class="id" title="var">alist</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span> is a tactic from the metatheory library for
    induction over association lists (such as the heap).  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_abs"><span class="id" title="lemma">apply_heap_abs</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_abs"><span class="id" title="lemma">apply_heap_abs</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_app"><span class="id" title="lemma">apply_heap_app</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Connect.html#e2"><span class="id" title="variable">e2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e2"><span class="id" title="variable">e2</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">h</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_app"><span class="id" title="lemma">apply_heap_app</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h3 class="section">Exercise: <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap_open"><span class="id" title="lemma">apply_heap_open</span></a></span></h3>


<div class="paragraph"> </div>

    This function is the <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a></span> analogue to
    <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a></span>, commuting the heap-based
    substitution with the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a></span> operation.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_open"><span class="id" title="lemma">apply_heap_open</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">e0</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a>)  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_open"><span class="id" title="axiom">apply_heap_open</span></a> : <span class="id" title="var">lngen</span>.<br/>

<br/>
</div>

<div class="doc">
This last lemma "unsimpl"s the <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a></span> function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="combine"><span class="id" title="lemma">combine</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a>) <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h2 class="section">Stacks as evaluation contexts</h2>

<div class="paragraph"> </div>

 Here is a quick lemma that uses the properties defined above.
    It shows that the stack behaves like an *evaluation context*,
    lifting a small-step reduction to a larger term.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_stack_cong"><span class="id" title="lemma">apply_stack_cong</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="var">default_simp</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab9"></a><h1 class="section">Connecting "freshening"</h1>

<div class="paragraph"> </div>

 The abstract machine uses the nominal <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a></span> operation to make sure
    that the variables in abstractions are "fresh".  To be able prove that
    this machine implements the step relation for LN terms, we need to
    connect this operation to a LN version of "freshening".

<div class="paragraph"> </div>

    The <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a></span> lemma below states that connection. If a variable <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a></span>
    is "fresh", then substituting with it (in the LN representation) is the
    same as swapping with it (in the nominal representation).

<div class="paragraph"> </div>

<pre>
Lemma swap_spec : forall  n w y,
    y `notin` fv_exp (nom_to_exp n) -&gt;
    w &lt;&gt; y -&gt;
    [w ~&gt; var_f y] (nom_to_exp n) =
    nom_to_exp (swap w y n).
</pre>

<div class="paragraph"> </div>

 
<div class="paragraph"> </div>

<a name="lab10"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a></span></h3>

<div class="paragraph"> </div>

 The <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a></span> proof depends on the following auxiliary lemma about the
    close operation --- that we can equivalently rename the atom that
    we are closing with. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a> <a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lemmas.html#close_exp_wrt_exp"><span class="id" title="definition">close_exp_wrt_exp</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
One difficulty of <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a></span> is that we need to use the induction
    not on direct subterms, but on those that have had a swapping applied
    to them. Swapping preserves the size of a nominal term, so we can
    prove this result by induction on <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#m"><span class="id" title="variable">m</span></a></span>, a bound on the size of the
    term.

<div class="paragraph"> </div>

    The difficulty in this proof comes from the <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#n_abs"><span class="id" title="constructor">n_abs</span></a></span> case. In this
    case, the term is is of the form <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#n_abs"><span class="id" title="constructor">n_abs</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a></span> for some binding
    variable <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span>. We don't know much about <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span>; it could be <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a></span>, or <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a></span>
    or some other variable. The first and last case are straightforward,
    but the middle case causes difficulty: even though <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> is not free in
    <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#n_abs"><span class="id" title="constructor">n_abs</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a></span>, it <i>is</i> free in <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a></span>. Therefore, our induction hypothesis
    doesn't apply.

<div class="paragraph"> </div>

    To solve this problem, we need to generate a completely fresh
    variable <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a></span> for the binder, use the lemma above to replace <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a></span> and
    <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a></span> with it, and then use the induction hypothesis.

<div class="paragraph"> </div>

 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="swap_spec_aux"><span class="id" title="lemma">swap_spec_aux</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">t</span> <span class="id" title="var">w</span> <span class="id" title="var">y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#size"><span class="id" title="definition">size</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9b077c369e19739ef880736ba34623ff"><span class="id" title="notation">≤</span></a> <a class="idref" href="Stlc.Connect.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">t</span> <span class="id" title="var">w</span> <span class="id" title="var">y</span> <span class="id" title="var">SZ</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Nominal.html#swap_var"><span class="id" title="definition">swap_var</span></a>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Nominal.html#swap_var"><span class="id" title="definition">swap_var</span></a>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="axiom">close_exp_wrt_exp_freshen</span></a> <span class="id" title="var">w</span> <span class="id" title="var">y</span>); <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="var">default_simp</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">z</span> <span class="id" title="keyword">for</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">t</span>) <span class="id" title="notation">\</span><span class="id" title="notation">u</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a> <span class="id" title="var">w</span> <span class="id" title="var">y</span> <span class="id" title="var">t</span>)) <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="notation">{{</span><span class="id" title="var">w</span><span class="id" title="notation">}}</span> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="notation">{{</span><span class="id" title="var">y</span><span class="id" title="notation">}}</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="axiom">close_exp_wrt_exp_freshen</span></a> <span class="id" title="var">y</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="axiom">close_exp_wrt_exp_freshen</span></a> <span class="id" title="var">w</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_close_exp_wrt_exp"><span class="id" title="lemma">subst_exp_close_exp_wrt_exp</span></a>; <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">y</span>:=<span class="id" title="var">z</span>); <span class="id" title="var">default_steps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">y</span>:=<span class="id" title="var">z</span>); <span class="id" title="var">default_steps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">y</span>:=<span class="id" title="var">y</span>); <span class="id" title="var">default_steps</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Nominal.html#shuffle_swap"><span class="id" title="lemma">shuffle_swap</span></a>; <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Stlc.Connect.html#fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Nominal.html#fv_nom_swap"><span class="id" title="lemma">fv_nom_swap</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#fv_nom_fv_exp_eq"><span class="id" title="lemma">fv_nom_fv_exp_eq</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm</span>; <span class="id" title="var">default_steps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="swap_spec"><span class="id" title="lemma">swap_spec</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> <span class="id" title="var">w</span> <span class="id" title="var">y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> (<a class="idref" href="Stlc.Nominal.html#swap"><span class="id" title="definition">swap</span></a> <a class="idref" href="Stlc.Connect.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Connect.html#swap_spec_aux"><span class="id" title="lemma">swap_spec_aux</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">t</span>:=<span class="id" title="var">t</span>)(<span class="id" title="var">m</span>:=<a class="idref" href="Stlc.Nominal.html#size"><span class="id" title="definition">size</span></a> <span class="id" title="var">t</span>); <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h2 class="section">Connection for alpha-equivalence</h2>

<div class="paragraph"> </div>

<a name="lab12"></a><h3 class="section">Challenge Exercise: <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#aeq_nom_to_exp"><span class="id" title="lemma">aeq_nom_to_exp</span></a></span></h3>


<div class="paragraph"> </div>

    Show that alpha-equivalence for the nominal representation is definitional
    equality for LN terms.

<div class="paragraph"> </div>

    This result is not necessary for the simulation lemmas below, but it
    is another example of the a proof that takes advantage of the
    <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a></span> and <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#close_exp_wrt_exp_freshen"><span class="id" title="lemma">close_exp_wrt_exp_freshen</span></a></span> lemmas  above.

<div class="paragraph"> </div>

    The second proof is much more challenging than the first and requires
    lemmas from <span class="inlinecode"><span class="id" title="var">Lemmas.v</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="aeq_nom_to_exp"><span class="id" title="lemma">aeq_nom_to_exp</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>, <a class="idref" href="Stlc.Nominal.html#aeq"><span class="id" title="inductive">aeq</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="nom_to_exp_eq_aeq"><span class="id" title="lemma">nom_to_exp_eq_aeq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>, <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Nominal.html#aeq"><span class="id" title="inductive">aeq</span></a> <a class="idref" href="Stlc.Connect.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="Stlc.Connect.html#n2"><span class="id" title="variable">n2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h1 class="section">Scoped configurations</h1>

<div class="paragraph"> </div>

 Not all abstract machine steps simulate small-steps of the
    substitution-based STLC.

<div class="paragraph"> </div>

    For example, if the domain of the heap is not unique (i.e. it has
    multiple definitions for the same variable) then its evaluation may
    not produce expected results.

<div class="paragraph"> </div>

    Similarly, if the <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#avoid"><span class="id" title="variable">avoid</span></a></span> set that we pass to each machine step does
    not include initial the free variables of the term, then we could
    capture them in strange ways.

<div class="paragraph"> </div>

    Therefore, we will restrict our correctness lemmas so that they only
    apply to <i>well-scoped</i> configurations; as defined below. 
<div class="paragraph"> </div>

<a name="lab14"></a><h2 class="section">Scoped heaps</h2>

<div class="paragraph"> </div>

 Well-scoped heaps behave "telescopically".  Each binding (x,e) added
    to the heap is for a unique name x and the free variables of e are
    bound in the remainder of the heap.

<div class="paragraph"> </div>

    The scoping relation is parameterized by <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a></span>, an "ambient
    scope". This will let us reason about the execution of the abstract
    machine for terms with free variables. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> (<span class="id" title="var">D</span> : <span class="id" title="abbreviation">atoms</span>) : <a class="idref" href="Stlc.Nominal.html#heap"><span class="id" title="definition">heap</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="scoped_nil"><span class="id" title="constructor">scoped_nil</span></a>  : <a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <span class="id" title="var">D</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;| <a name="scoped_cons"><span class="id" title="constructor">scoped_cons</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="var">D</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <span class="id" title="var">D</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <span class="id" title="var">D</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <span class="id" title="var">D</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h3 class="section">Recommended (Challenge) Exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap_get"><span class="id" title="lemma">apply_heap_get</span></a></span></h3>


<div class="paragraph"> </div>

    We can use <span class="inlinecode"><span class="id" title="definition">get</span></span> to look up expressions in the heap. However, to know that
    we have the right result we need to know that the heap is well-scoped,
    i.e.  that later bindings do not affect earlier ones.

<div class="paragraph"> </div>

    State a lemma about the scoping of expressions that appear in the heap and
    use it to finish the <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#apply_heap_get"><span class="id" title="lemma">apply_heap_get</span></a></span> lemma below.  
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_heap_get"><span class="id" title="lemma">apply_heap_get</span></a> :  <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span> <span class="id" title="var">D</span> <span class="id" title="var">x</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">get</span> <a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#apply_heap"><span class="id" title="definition">apply_heap</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="tactic">intros</span>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "x is at the current heap location".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="tactic">auto</span>. <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "x is later in the heap".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="tactic">auto</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h2 class="section">Scoped stacks</h2>

<div class="paragraph"> </div>

 We also care about the free variables that can appear in stacks. (We
    will use this in the definition of well-scoped configurations below.)

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="fv_stack"><span class="id" title="definition">fv_stack</span></a> <span class="id" title="var">s</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <span class="id" title="notation">{}</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Nominal.html#n_app2"><span class="id" title="constructor">n_app2</span></a> <span class="id" title="var">e</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <span class="id" title="var">e</span>) <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#fv_stack"><span class="id" title="definition">fv_stack</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Stacks that are well-scoped can discard irrelevant bindings
    from the heap. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="apply_stack_fresh_eq"><span class="id" title="lemma">apply_stack_fresh_eq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">x</span> <span class="id" title="var">e1</span> <span class="id" title="var">h</span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Connect.html#fv_stack"><span class="id" title="definition">fv_stack</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a>) <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#apply_stack"><span class="id" title="definition">apply_stack</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHs</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h1 class="section">Simulation</h1>

<div class="paragraph"> </div>

 A scoped configuration is one where all free variables in terms
    are either bound in the heap or come from <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a></span> 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <a name="scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> : <span class="id" title="abbreviation">atoms</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Nominal.html#configuration"><span class="id" title="definition">configuration</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="scoped_conf_witness"><span class="id" title="constructor">scoped_conf_witness</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_heap"><span class="id" title="inductive">scoped_heap</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#fv_stack"><span class="id" title="definition">fv_stack</span></a> <a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#simulate_step"><span class="id" title="lemma">simulate_step</span></a></span></h3>


<div class="paragraph"> </div>

    After stepping through the simulation result below, finish the
    missing case.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simulate_step"><span class="id" title="lemma">simulate_step</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">h'</span> <span class="id" title="var">e'</span> <span class="id" title="var">s'</span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#TakeStep"><span class="id" title="constructor">TakeStep</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h'"><span class="id" title="variable">h'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h'"><span class="id" title="variable">h'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>) (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h'"><span class="id" title="variable">h'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e'"><span class="id" title="variable">e'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">h'</span> <span class="id" title="var">e'</span> <span class="id" title="var">s'</span> <span class="id" title="var">STEP</span> <span class="id" title="var">SCOPE</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">SCOPE</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">SCOPE</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="Stlc.Nominal.html#isVal"><span class="id" title="definition">isVal</span></a> <span class="id" title="var">e</span>) <span class="id" title="var">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">f</span> <span class="id" title="var">eqn</span>:?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span> <span class="id" title="var">eqn</span>:?; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="lemma">AtomSetProperties.In_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="lemma">atom_fresh</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">STEP</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#combine"><span class="id" title="lemma">combine</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_stack_fresh_eq"><span class="id" title="lemma">apply_stack_fresh_eq</span></a>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Connect.html#apply_stack_cong"><span class="id" title="lemma">apply_stack_cong</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <span class="id" title="var">x0</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Stlc.Connect.html#swap_spec"><span class="id" title="lemma">swap_spec</span></a>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="Stlc.Lemmas.html#subst_exp_spec"><span class="id" title="lemma">subst_exp_spec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">default_simp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>; <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Definitions.html#step_beta"><span class="id" title="constructor">step_beta</span></a>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="Stlc.Connect.html#apply_heap_abs"><span class="id" title="lemma">apply_heap_abs</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Connect.html#apply_heap_lc"><span class="id" title="lemma">apply_heap_lc</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">lngen</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H4</span>. <span class="id" title="var">fsetdec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span> <span class="id" title="var">eqn</span>:?; <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="definition">get</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span>) <span class="id" title="var">eqn</span>:?; <span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">STEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Connect.html#apply_heap_get"><span class="id" title="axiom">apply_heap_get</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">D</span>:= <span class="id" title="var">D</span>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">STEP</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">STEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Connect.html#apply_heap_app"><span class="id" title="lemma">apply_heap_app</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab19"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#simulate_done"><span class="id" title="lemma">simulate_done</span></a></span></h3>


<div class="paragraph"> </div>

    Show that if the machine says <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#Done"><span class="id" title="constructor">Done</span></a></span> then the LN term is a value.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simulate_done"><span class="id" title="lemma">simulate_done</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> (<span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#Done"><span class="id" title="constructor">Done</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#is_value"><span class="id" title="definition">is_value</span></a> (<a class="idref" href="Stlc.Connect.html#nom_to_exp"><span class="id" title="definition">nom_to_exp</span></a> <a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.  <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab20"></a><h3 class="section">Challenge exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#simulate_error"><span class="id" title="lemma">simulate_error</span></a></span></h3>


<div class="paragraph"> </div>

    Show that if the machine produces an error, the small step relation
    is stuck.

<div class="paragraph"> </div>

    This is a challenge exercise because you will need to figure out
    at least one nontrivial auxiliary lemma.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simulate_error"><span class="id" title="lemma">simulate_error</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> (<span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#Error"><span class="id" title="constructor">Error</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">∃</span></a> <span class="id" title="var">e0</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Connect.html#decode"><span class="id" title="definition">decode</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>) <a class="idref" href="Stlc.Connect.html#e0"><span class="id" title="variable">e0</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab21"></a><h3 class="section">Challenge exercise <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#machine_is_scoped"><span class="id" title="lemma">machine_is_scoped</span></a></span></h3>


<div class="paragraph"> </div>

    Show that if the abstract machine is scoped, then any resulting
    configurations are also scoped. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="machine_is_scoped"><span class="id" title="lemma">machine_is_scoped</span></a>: <span class="id" title="keyword">∀</span> <span class="id" title="var">D</span> <span class="id" title="var">h</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">conf'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Nominal.html#machine_step"><span class="id" title="definition">machine_step</span></a> (<span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Nominal.html#TakeStep"><span class="id" title="constructor">TakeStep</span></a> <span class="id" title="var">_</span> <a class="idref" href="Stlc.Connect.html#conf'"><span class="id" title="variable">conf'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Connect.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Connect.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Connect.html#scoped_conf"><span class="id" title="inductive">scoped_conf</span></a> <a class="idref" href="Stlc.Connect.html#D"><span class="id" title="variable">D</span></a> <a class="idref" href="Stlc.Connect.html#conf'"><span class="id" title="variable">conf'</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>