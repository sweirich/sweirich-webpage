<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Stlc.Definitions</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Stlc.Definitions</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab10"></a><h1 class="section">Definition of STLC</h1>

<div class="paragraph"> </div>

 This file containes all of the definitions for a locally-nameless
    representation of a Curry-Style simply-typed lambda calculus.

<div class="paragraph"> </div>

    This file was generated via Ott from `stlc.ott` and then edited to
    include explanation about the definitions. As a result, it is gathers
    all of the STLC definitions in one place, but the associated exercises
    are found elsewhere in the tutorial.  You'll want to refer back to
    this file as you progress through the rest of the material. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Metalib.Metatheory</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h1 class="section">Syntax of STLC</h1>

<div class="paragraph"> </div>

 We use a locally nameless representation for the simply-typed lambda
    calculus, where bound variables are represented as natural numbers (de
    Bruijn indices) and free variables are represented as <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s.

<div class="paragraph"> </div>

    The type <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>, defined in the Metatheory library, represents names.
    Equality on names is decidable, and it is possible to generate an atom
    fresh for any given finite set of atoms (<span class="inlinecode"><span class="id" title="lemma">atom_fresh</span></span>).

<div class="paragraph"> </div>

    Note: the type <span class="inlinecode"><span class="id" title="abbreviation">var</span></span> is notation for <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="typ"><span class="id" title="inductive">typ</span></a> : <span class="id" title="keyword">Set</span> :=  <br/>
&nbsp;| <a name="typ_base"><span class="id" title="constructor">typ_base</span></a> : <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a><br/>
&nbsp;| <a name="typ_arrow"><span class="id" title="constructor">typ_arrow</span></a> (<span class="id" title="var">T1</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>) (<span class="id" title="var">T2</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>).<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="exp"><span class="id" title="inductive">exp</span></a> : <span class="id" title="keyword">Set</span> :=  <br/>
&nbsp;| <a name="var_b"><span class="id" title="constructor">var_b</span></a> (<span class="id" title="var">_</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;| <a name="var_f"><span class="id" title="constructor">var_f</span></a> (<span class="id" title="var">x</span>:<span class="id" title="abbreviation">var</span>)<br/>
&nbsp;| <a name="abs"><span class="id" title="constructor">abs</span></a> (<span class="id" title="var">e</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>)<br/>
&nbsp;| <a name="app"><span class="id" title="constructor">app</span></a> (<span class="id" title="var">e1</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) (<span class="id" title="var">e2</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h1 class="section">Substitution</h1>

<div class="paragraph"> </div>

 Substitution replaces a free variable with a term.  The definition
    below is simple for two reasons:
<ul class="doclist">
<li> Because bound variables are represented using indices, there
        is no need to worry about variable capture.

</li>
<li> We assume that the term being substituted in is locally
        closed.  Thus, there is no need to shift indices when
        passing under a binder.

</li>
</ul>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> keyword defines a Coq function.  As all functions in Coq
    must be total.  The annotation <span class="inlinecode">{<span class="id" title="keyword">struct</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a>}</span> indicates the termination
    metric---all recursive calls in this definition are made to arguments that
    are structurally smaller than <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.

<div class="paragraph"> </div>

    Note also that <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a></span> uses <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">==</span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a></span> for decidable equality.  This
    operation is defined in the Metatheory library.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="subst_exp"><span class="id" title="definition">subst_exp</span></a> (<span class="id" title="var">u</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) (<span class="id" title="var">y</span>:<span class="id" title="abbreviation">var</span>) (<span class="id" title="var">e</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">e</span>} : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> <span class="id" title="var">n</span>)   ⇒ <a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span>)   ⇒ (<span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="notation">==</span> <a class="idref" href="Stlc.Definitions.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">else</span> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <span class="id" title="var">e1</span>)    ⇒ <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a> <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Definitions.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="var">e1</span>)<br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a> <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Definitions.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a> <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Definitions.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="var">e2</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h1 class="section">Free variables</h1>

<div class="paragraph"> </div>

 The function <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a></span>, defined below, calculates the set of free
    variables in an expression.  Because we are using a locally
    nameless representation, where bound variables are represented as
    indices, any name we see is a free variable of a term.  In
    particular, this makes the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> case simple.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="fv_exp"><span class="id" title="definition">fv_exp</span></a> (<span class="id" title="var">e_5</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) : <span class="id" title="abbreviation">vars</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Definitions.html#e_5"><span class="id" title="variable">e_5</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> <span class="id" title="var">nat</span>)   ⇒ <span class="id" title="notation">{}</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span>)   ⇒ <span class="id" title="notation">{{</span><span class="id" title="var">x</span><span class="id" title="notation">}}</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <span class="id" title="var">e</span>)     ⇒ <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <span class="id" title="var">e2</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The type <span class="inlinecode"><span class="id" title="abbreviation">vars</span></span> represents a finite set of elements of type <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>.
    The notations for the finite set definitions (empty set `{}`, singleton
    `<a href="x">x</a>` and union `\u`) is also defined in the Metatheory library.  
<div class="paragraph"> </div>

<a name="lab14"></a><h1 class="section">Opening</h1>

<div class="paragraph"> </div>

 Opening replaces an index with a term.  It corresponds to informal
    substitution for a bound variable, such as in the rule for beta reduction.
    Note that only "dangling" indices (those that do not refer to any
    abstraction) can be opened.  Opening has no effect for terms that are
    locally closed.

<div class="paragraph"> </div>

    Natural numbers are just an inductive datatype with two constructors: <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a></span>
    (as in the letter 'oh', not 'zero') and <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a></span>, defined in
    Coq.Init.Datatypes.  Coq allows literal natural numbers to be written
    using standard decimal notation, e.g., 0, 1, 2, etc.
    The function <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Compare_dec.html#lt_eq_lt_dec"><span class="id" title="definition">lt_eq_lt_dec</span></a></span> compares its two arguments for ordering.

<div class="paragraph"> </div>

    We do not assume that zero is the only unbound index in the term.
    Consequently, we must substract one when we encounter other unbound
    indices (i.e. the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#inright"><span class="id" title="constructor">inright</span></a></span> case).

<div class="paragraph"> </div>

    However, we do assume that the argument <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a></span> is locally closed.  This
    assumption simplifies the implementation since we do not need to shift
    indices in <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a></span> when passing under a binder. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="open_exp_wrt_exp_rec"><span class="id" title="definition">open_exp_wrt_exp_rec</span></a> (<span class="id" title="var">k</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">u</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) (<span class="id" title="var">e</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">e</span>}: <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> <span class="id" title="var">n</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Compare_dec.html#lt_eq_lt_dec"><span class="id" title="definition">lt_eq_lt_dec</span></a> <span class="id" title="var">n</span> <a class="idref" href="Stlc.Definitions.html#k"><span class="id" title="variable">k</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#inleft"><span class="id" title="constructor">inleft</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#left"><span class="id" title="constructor">left</span></a> <span class="id" title="var">_</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#inleft"><span class="id" title="constructor">inleft</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#right"><span class="id" title="constructor">right</span></a> <span class="id" title="var">_</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#inright"><span class="id" title="constructor">inright</span></a> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> (<span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">-</span></a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <span class="id" title="var">e</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp_rec"><span class="id" title="definition">open_exp_wrt_exp_rec</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Stlc.Definitions.html#k"><span class="id" title="variable">k</span></a>) <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a>)<br/>
&nbsp;&nbsp;| (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>) ⇒ <a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp_rec"><span class="id" title="definition">open_exp_wrt_exp_rec</span></a> <a class="idref" href="Stlc.Definitions.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="var">e1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp_rec"><span class="id" title="definition">open_exp_wrt_exp_rec</span></a> <a class="idref" href="Stlc.Definitions.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="var">e2</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a> <span class="id" title="var">e</span> <span class="id" title="var">u</span> := <a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp_rec"><span class="id" title="definition">open_exp_wrt_exp_rec</span></a> 0 <a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h1 class="section">Notations</h1>

<div class="paragraph"> </div>

 Many common applications of opening replace index zero with an
    expression or variable.  The following definition provides a
    convenient shorthand for such uses.  Note that the order of
    arguments is switched relative to the definition above.  For
    example, <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>)</span> can be read as "substitute the variable <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span>
    for index <span class="inlinecode">0</span> in <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>" and "open <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span> with the variable <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span>."

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="StlcNotations"><span class="id" title="module">StlcNotations</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">&quot;</span></a>[ z ~&gt; u ] e" := (<a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a> <span class="id" title="var">u</span> <span class="id" title="var">z</span> <span class="id" title="var">e</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 68) : <span class="id" title="var">exp_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="StlcNotations.open"><span class="id" title="abbreviation">open</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>     := (<a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>).<br/>
<span class="id" title="keyword">Notation</span> <a name="5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">&quot;</span></a>e ^ x"        := (<a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a> <span class="id" title="var">e</span> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <span class="id" title="var">x</span>)) : <span class="id" title="var">exp_scope</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Stlc.Definitions.html#StlcNotations"><span class="id" title="module">StlcNotations</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">StlcNotations</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">exp_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h1 class="section">Local closure</h1>

<div class="paragraph"> </div>

 Recall that <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a></span> admits terms that contain unbound indices.  We say that
    a term is locally closed when no indices appearing in it are unbound.  The
    proposition <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span> holds when an expression <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span> is locally closed.

<div class="paragraph"> </div>

    The inductive definition below formalizes local closure such that the
    resulting induction principle serves as the structural induction principle
    over (locally closed) expressions.  In particular, unlike induction for
    type <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a></span>, there are no cases for bound variables.  Thus, the induction
    principle corresponds more closely to informal practice than the one
    arising from the definition of pre-terms.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="lc_exp"><span class="id" title="inductive">lc_exp</span></a> : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;| <a name="lc_var_f"><span class="id" title="constructor">lc_var_f</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span>:<span class="id" title="abbreviation">var</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a>)<br/>
&nbsp;| <a name="lc_abs"><span class="id" title="constructor">lc_abs</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">e</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> , <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#open"><span class="id" title="abbreviation">open</span></a> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a>))<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a>)<br/>
&nbsp;| <a name="lc_app"><span class="id" title="constructor">lc_app</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">e1</span> <span class="id" title="var">e2</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h1 class="section">Typing contexts</h1>

<div class="paragraph"> </div>

 We represent typing contexts as association lists (lists of pairs of
    keys and values) whose keys are <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="ctx"><span class="id" title="definition">ctx</span></a> : <span class="id" title="keyword">Set</span> := <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<span class="id" title="abbreviation">atom</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>).<br/>

<br/>
</div>

<div class="doc">
For STLC, contexts bind <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s to <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a></span>s.

<div class="paragraph"> </div>

    Lists are defined in Coq's standard library, with the constructors <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a></span>
    and <span class="inlinecode"><span class="id" title="var">cons</span></span>.  The list library includes the <span class="inlinecode">::</span> notation for cons as well
    as standard list operations such as append, map, and fold. The infix
    operation <span class="inlinecode">++</span> is list append.

<div class="paragraph"> </div>

    The Metatheory library extends this reasoning by instantiating the
    AssocList library to provide support for association lists whose keys are
    <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s.  Everything in this library is polymorphic over the type of
    objects bound in the environment.  Look in AssocList.v for additional
    details about the functions and predicates that we mention below.
 
<div class="paragraph"> </div>

<a name="lab18"></a><h1 class="section">Typing relation</h1>

<div class="paragraph"> </div>

 The definition of the typing relation is straightforward.  In
    order to ensure that the relation holds for only well-formed
    environments, we check in the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case that the
    environment is <span class="inlinecode"><span class="id" title="inductive">uniq</span></span>.  The structure of typing derivations
    implicitly ensures that the relation holds only for locally closed
    expressions.

<div class="paragraph"> </div>

    Finally, note the use of cofinite quantification in
    the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="typing"><span class="id" title="inductive">typing</span></a> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;| <a name="typing_var"><span class="id" title="constructor">typing_var</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">G</span>:<a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) (<span class="id" title="var">x</span>:<span class="id" title="abbreviation">var</span>) (<span class="id" title="var">T</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">binds</span> <a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a>  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a><br/>
&nbsp;| <a name="typing_abs"><span class="id" title="constructor">typing_abs</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">L</span>:<span class="id" title="abbreviation">vars</span>) (<span class="id" title="var">G</span>:<a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) (<span class="id" title="var">T1</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>) (<span class="id" title="var">e</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) (<span class="id" title="var">T2</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> , <a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">notin</span> <a class="idref" href="Stlc.Definitions.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Definitions.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a>) (<a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Definitions.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stlc.Definitions.html#T2"><span class="id" title="variable">T2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>  <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Definitions.html#typ_arrow"><span class="id" title="constructor">typ_arrow</span></a> <a class="idref" href="Stlc.Definitions.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="Stlc.Definitions.html#T2"><span class="id" title="variable">T2</span></a>)<br/>
&nbsp;| <a name="typing_app"><span class="id" title="constructor">typing_app</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">G</span>:<a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) (<span class="id" title="var">e1</span> <span class="id" title="var">e2</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) (<span class="id" title="var">T2</span> <span class="id" title="var">T1</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> (<a class="idref" href="Stlc.Definitions.html#typ_arrow"><span class="id" title="constructor">typ_arrow</span></a> <a class="idref" href="Stlc.Definitions.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="Stlc.Definitions.html#T2"><span class="id" title="variable">T2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Stlc.Definitions.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a>) <a class="idref" href="Stlc.Definitions.html#T2"><span class="id" title="variable">T2</span></a> .<br/>

<br/>
</div>

<div class="doc">
<a name="lab19"></a><h1 class="section">Values and Small-step Evaluation</h1>

<div class="paragraph"> </div>

 Finally, we define values and a call-by-name small-step evaluation
    relation. In STLC, abstractions are the only value. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="is_value"><span class="id" title="definition">is_value</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Stlc.Definitions.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <span class="id" title="var">_</span>   ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span>       ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
For <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#step_beta"><span class="id" title="constructor">step_beta</span></a></span>, note that we use <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a></span> instead of
    substitution --- no variable names are involved.

<div class="paragraph"> </div>

    Note also the hypotheses in <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a></span> that ensure that the relation holds
    only for locally closed terms.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="step"><span class="id" title="inductive">step</span></a> : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;| <a name="step_beta"><span class="id" title="constructor">step_beta</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">e1</span> <span class="id" title="var">e2</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a>  (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a>) <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a>)  (<a class="idref" href="Stlc.Definitions.html#open"><span class="id" title="abbreviation">open</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a>)<br/>
&nbsp;| <a name="step_app"><span class="id" title="constructor">step_app</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">e1</span> <span class="id" title="var">e2</span> <span class="id" title="var">e1'</span>:<a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Definitions.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Definitions.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a>) (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Definitions.html#e1'"><span class="id" title="variable">e1'</span></a> <a class="idref" href="Stlc.Definitions.html#e2"><span class="id" title="variable">e2</span></a>).<br/>

<br/>
<span class="id" title="keyword">Hint Constructors</span> <a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>