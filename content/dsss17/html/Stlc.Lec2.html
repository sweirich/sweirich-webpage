<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Stlc.Lec2</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Stlc.Lec2</h1>

<div class="code">
</div>

<div class="doc">
                                                                     <a name="lab45"></a><h1 class="section">Typing: preservation and progress</h1>
                                                                      
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Metalib.Metatheory</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Definitions.html#"><span class="id" title="library">Stlc.Definitions</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">StlcNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Lemmas.html#"><span class="id" title="library">Stlc.Lemmas</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Lec1.html#"><span class="id" title="library">Stlc.Lec1</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab46"></a><h1 class="section">Typing contexts</h1>

<div class="paragraph"> </div>

 We represent contexts as association lists (lists of pairs of
    keys and values) whose keys are <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s.   
<div class="paragraph"> </div>

 For STLC, contexts bind <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s to <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a></span>s.  We define an
    abbreviation <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a></span> for the type of these contexts.

<div class="paragraph"> </div>

    Lists are defined in Coq's standard library, with the constructors
    <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a></span> and <span class="inlinecode"><span class="id" title="var">cons</span></span>.  The list library includes the <span class="inlinecode">::</span> notation
    for cons as well as standard list operations such as append, map,
    and fold. The infix operation "++" is list append.

<div class="paragraph"> </div>

    The Metatheory library extends this reasoning by instantiating the
    AssocList library to provide support for association lists whose
    keys are <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s.  Everything in this library is polymorphic over
    the type of objects bound in the context.  Look in AssocList
    for additional details about the functions and predicates that we
    mention below.  
<div class="paragraph"> </div>

 Context equality 
<div class="paragraph"> </div>

 When reasoning about contexts, we often need to talk about
    bindings in the "middle" of an context. Therefore, it is common
    for lemmas and definitions to use list append in their statements.
    Unfortunately, list append is associative, so two Coq expressions may
    denote the same context even though they are not equal.

<div class="paragraph"> </div>

    The tactic <span class="inlinecode"><span class="id" title="var">simpl_env</span></span> reassociates all concatenations of
    contexts to the right.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="append_assoc_demo"><span class="id" title="lemma">append_assoc_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E0</span> <span class="id" title="var">E1</span> <span class="id" title="var">E2</span> <span class="id" title="var">E3</span>:<a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#E0"><span class="id" title="variable">E0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#E1"><span class="id" title="variable">E1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E2"><span class="id" title="variable">E2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E3"><span class="id" title="variable">E3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Lec2.html#E0"><span class="id" title="variable">E0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E1"><span class="id" title="variable">E1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E2"><span class="id" title="variable">E2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E3"><span class="id" title="variable">E3</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>. &nbsp;&nbsp;<span class="id" title="var">simpl_env</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
To make contexts easy to read, instead of building them from
    <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a></span> and <span class="inlinecode"><span class="id" title="var">cons</span></span>, we prefer to build them from the following
    components:
<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a></span>: The empty list.

</li>
<li> <span class="inlinecode"><span class="id" title="var">one</span></span>: Lists consisting of exactly one item.

</li>
<li> <span class="inlinecode">++</span>:  List append.

</li>
</ul>

<div class="paragraph"> </div>

   Furthermore, we introduce compact notation for one (singleton lists):
   <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">¬</span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a>)</span> is the same as <span class="inlinecode"><span class="id" title="var">one</span></span> <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>,</span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a>)</span>.

<div class="paragraph"> </div>

 The simpl_env tactic actually puts lists built from only nil, one
    and <span class="inlinecode">++</span> into a "normal form". This process reassociates all appends
    to the right, removes extraneous nils and converts cons to singleton
    lists with an append.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="simpl_env_demo"><span class="id" title="lemma">simpl_env_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="abbreviation">atom</span>) (<span class="id" title="var">T1</span> <span class="id" title="var">T2</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>) (<span class="id" title="var">E</span> <span class="id" title="var">F</span>:<a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">((</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">simpl_env</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that the <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> tactic doesn't produce the "normal form" for
    contexts. It should always be followed up with <span class="inlinecode"><span class="id" title="var">simpl_env</span></span>.

<div class="paragraph"> </div>

    Furthermore, to convert an context to any equivalent form
    other than the normal form (perhaps to apply a lemma) use the
    tactic <span class="inlinecode"><span class="id" title="var">rewrite_env</span></span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="rewrite_env_demo"><span class="id" title="lemma">rewrite_env_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="abbreviation">atom</span>) (<span class="id" title="var">T</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>) <span class="id" title="var">P</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">E</span>, <a class="idref" href="Stlc.Lec2.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">T</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rewrite_env</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a><span class="id" title="var">T</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Context operations. 
<div class="paragraph"> </div>

 The ternary predicate <span class="inlinecode"><span class="id" title="definition">binds</span></span> holds when a given binding is
    present somewhere in an context.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="binds_demo"><span class="id" title="lemma">binds_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span>:<span class="id" title="abbreviation">atom</span>) (<span class="id" title="var">T</span>:<a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>) (<span class="id" title="var">E</span> <span class="id" title="var">F</span>:<a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>),<br/>
&nbsp;&nbsp;<span class="id" title="definition">binds</span> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> (<a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The function <span class="inlinecode"><span class="id" title="definition">dom</span></span> computes the domain of an context,
    returning a finite set of <span class="inlinecode"><span class="id" title="abbreviation">atom</span></span>s. Note that we cannot use Coq's
    equality for finite sets, we must instead use a defined relation
    <span class="inlinecode">=</span> for atom set equality.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="dom_demo"><span class="id" title="lemma">dom_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="abbreviation">atom</span>) (<span class="id" title="var">T</span> : <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>),<br/>
&nbsp;&nbsp;<span class="id" title="definition">dom</span> (<a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>) <span class="id" title="notation">[=]</span> <span class="id" title="abbreviation">singleton</span> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The unary predicate <span class="inlinecode"><span class="id" title="inductive">uniq</span></span> holds when each atom is bound at most
    once in an context.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="uniq_demo"><span class="id" title="lemma">uniq_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="abbreviation">atom</span>) (<span class="id" title="var">T</span> : <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="inductive">uniq</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab47"></a><h1 class="section">Typing relation and cofinite quantification</h1>

<div class="paragraph"> </div>

 The typing relation in the STLC definition states the typing rule for
    abstractions in a particular way.

<div class="paragraph"> </div>

<pre>
typing_abs
     : forall (L : atoms) (G : ctx) (T1 : typ) (e : exp) (T2 : typ),
       (forall x : atom,
        x `notin` L -&gt; typing ([(x, T1)] ++ G) (open e (var_f x)) T2) -&gt;
       typing G (abs e) (typ_arrow T1 T2)
</pre>

<div class="paragraph"> </div>

   To show that abstractions are well-typed, we must show that the body
   of the abstraction is well-typed for any choice of variable, except
   those from some unspecified set `L`.

<div class="paragraph"> </div>

   This type of rule differs from the quantification in the
   <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#lc_abs"><span class="id" title="constructor">lc_abs</span></a></span> rule (which does not restrict the variables at all) or
   the <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#lc_abs_exists"><span class="id" title="lemma">lc_abs_exists</span></a></span> version (which only applies for one particular
   variable. We call this version "co-finite" quantification.

<div class="paragraph"> </div>

   To see why this version is necessary, we will start with a more
   traditional version of the rules that only uses a single variable
   in the abs rule and then see what goes wrong.
   (We say that the <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a></span> judgement below uses "exists-fresh"
   quantification in the abs rule.)

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="typing_e"><span class="id" title="inductive">typing_e</span></a> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="typing_e_var"><span class="id" title="constructor">typing_e_var</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">atom</span>) <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">binds</span> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a><br/>
&nbsp;&nbsp;| <a name="typing_e_abs"><span class="id" title="constructor">typing_e_abs</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) (<a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Definitions.html#typ_arrow"><span class="id" title="constructor">typ_arrow</span></a> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a>)<br/>
&nbsp;&nbsp;| <a name="typing_e_app"><span class="id" title="constructor">typing_e_app</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e1"><span class="id" title="variable">e1</span></a> (<a class="idref" href="Stlc.Definitions.html#typ_arrow"><span class="id" title="constructor">typ_arrow</span></a> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> <a class="idref" href="Stlc.Lec2.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Lec2.html#e2"><span class="id" title="variable">e2</span></a>) <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a>.<br/>
<span class="id" title="keyword">Hint Constructors</span> <a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab48"></a><h1 class="section">Weakening</h1>

<div class="paragraph"> </div>

 Weakening states that if an expression is typeable in some
    context, then it is typeable in any well-formed extension of
    that context.  This property is needed to prove the
    substitution lemma.

<div class="paragraph"> </div>

    As stated below, this lemma is not directly proveable.  The
    natural way to try proving this lemma proceeds by induction on the
    typing derivation for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_weakening_0"><span class="id" title="lemma">typing_weakening_0</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span> <span class="id" title="var">J</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "typing_abs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Stlc.Lec2.html#typing_e_abs"><span class="id" title="constructor">typing_e_abs</span></a> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
We are stuck in the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case because the induction
    hypothesis <span class="inlinecode"><span class="id" title="var">IHtyping_e</span></span> applies only when we weaken the context at its
    head.  In this case, however, we need to weaken the context in
    the middle; compare the conclusion at the point where we're stuck
    to the hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span>, which comes from the given typing derivation.

<div class="paragraph"> </div>

    We can obtain a more useful induction hypothesis by changing the
    statement to insert new bindings into the middle of the
    context, instead of at the head.  However, the proof still
    gets stuck, as can be seen by examining each of the cases in
    the proof below.

<div class="paragraph"> </div>

    Note: To view subgoal n in a proof, use the command "<span class="inlinecode"><span class="id" title="keyword">Show</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#n"><span class="id" title="variable">n</span></a></span>".
    To work on subgoal n instead of the first one, use the command
    "<span class="inlinecode"><span class="id" title="var">Focus</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#n"><span class="id" title="variable">n</span></a></span>".

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_weakening_strengthened_0"><span class="id" title="lemma">typing_weakening_strengthened_0</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">G</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">G</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span> <span class="id" title="var">J</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "typing_var".<br/>
&nbsp;&nbsp;<span class="id" title="var">Focus</span> 2.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "typing_abs".<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The hypotheses in the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case include an context
    <span class="inlinecode"><span class="id" title="var">G0</span></span> that that has no relation to what we need to prove.  The
    missing fact we need is that <span class="inlinecode"><span class="id" title="var">G0</span></span> <span class="inlinecode">=</span> <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#E"><span class="id" title="variable">E</span></a>)</span>.

<div class="paragraph"> </div>

    The problem here arises from the fact that Coq's <span class="inlinecode"><span class="id" title="tactic">induction</span></span>
    tactic lets us only prove something about all typing derivations.
    While it's clear to us that weakening applies to all typing
    derivations, it's not clear to Coq, because the context is
    written using concatenation.  The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic expects that
    all arguments to a judgement are variables.  So we see <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#E0"><span class="id" title="variable">E0</span></a></span> in the
    proof instead of <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#E"><span class="id" title="variable">E</span></a>)</span>.

<div class="paragraph"> </div>

    The solution is to restate the lemma.  For example, we can prove

<div class="paragraph"> </div>

<pre>
  forall E F E' e T, typing E' e T -&gt;
  forall G, E' = G ++ E -&gt; uniq (G ++ F ++ E) -&gt; typing (G ++ F ++ E) e T.
</pre>

<div class="paragraph"> </div>

    The equality gets around the problem with Coq's <span class="inlinecode"><span class="id" title="tactic">induction</span></span>
    tactic.  The placement of the <span class="inlinecode">(<span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#G"><span class="id" title="variable">G</span></a>)</span> quantifier gives us a
    sufficiently strong induction hypothesis in the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case.

<div class="paragraph"> </div>

    However, we prefer not to state the lemma in the way shown above,
    since it is not as readable as the original statement.  Instead,
    we use a tactic to introduce the equality within the proof itself.
    The tactic <span class="inlinecode">(<span class="id" title="var">remember</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">t'</span>)</span> replaces an object <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a></span> with the
    identifier <span class="inlinecode"><span class="id" title="var">t'</span></span> everywhere in the goal and introduces an equality
    <span class="inlinecode"><span class="id" title="var">t'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#t"><span class="id" title="variable">t</span></a></span> into the context.  It is often combined with <span class="inlinecode"><span class="id" title="tactic">generalize</span></span>
    <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>, as illustrated below.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_weakening_strengthened_1"><span class="id" title="lemma">typing_weakening_strengthened_1</span></a> :  <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">G</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">G</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">G</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">E</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">E'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">G</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">G0</span> <span class="id" title="var">Eq</span> <span class="id" title="var">Uniq</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "typing_var". <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "typing_abs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<a class="idref" href="Stlc.Lec2.html#typing_e_abs"><span class="id" title="constructor">typing_e_abs</span></a> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a>.<br/>

<br/>
</div>

<div class="doc">
At this point, we are very close. However, there is still one issue. We
    cannot show that <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> is fresh for the weakened context <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a></span>.

<div class="paragraph"> </div>

    This is the difficulty with the definition of <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a></span>. As in the local
    closure judgement, the induction hypotheses is not strong enough in the
    <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> case.

<div class="paragraph"> </div>

    However, this time, we take a slightly different solution, with the
    cofinite quantification of the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> rule.

<div class="paragraph"> </div>

<pre>
| typing_abs :
    forall (L : atoms) (G : ctx) (T1 : typ) (e : exp) (T2 : typ),
    (forall x, x `notin` L -&gt; typing ([(x, T1)] ++ G) (e ^ x) T2) -&gt;
    typing (abs e) (typ_arrow T1 T2) </pre>

<div class="paragraph"> </div>

&gt;&gt;

<div class="paragraph"> </div>

   The advantage of this definition is that it is easier to derive
   the "exists-fresh" version of the rule
   <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_e_abs"><span class="id" title="constructor">typing_e_abs</span></a></span> as a lemma, than the version we used in <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a></span>.
   (See below, we prove this lemma after we show substitution.) At the same
   time, this version of the rule is sufficiently expressive to complete
   the proof of weakening.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab49"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_weakening_strengthened"><span class="id" title="lemma">typing_weakening_strengthened</span></a></span></h3>


<div class="paragraph"> </div>

    Complete the proof below, using the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a></span> relation from <span class="inlinecode"><span class="id" title="var">Definitions.v</span></span>.

<div class="paragraph"> </div>

    HINTS:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case follows from <span class="inlinecode"><span class="id" title="var">binds_weaken</span></span>, the
         weakening lemma for the <span class="inlinecode"><span class="id" title="definition">binds</span></span> relation.

<div class="paragraph"> </div>


</li>
<li> The <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case follows from the induction
         hypothesis, but the <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic may be unable to unify
         things as you might expect.

<div class="paragraph"> </div>

<ul class="doclist">
<li>- You'll need to specify the set to avoid with
              (L := dom (G0 ++ F ++ E) \u L)).

<div class="paragraph"> </div>


</li>
<li>- In order to apply the induction hypothesis, use
              <span class="inlinecode"><span class="id" title="var">rewrite_env</span></span> to reassociate the list operations.

<div class="paragraph"> </div>


</li>
<li>- After applying the induction hypothesis, use
              <span class="inlinecode"><span class="id" title="var">simpl_env</span></span> to use <span class="inlinecode"><span class="id" title="var">uniq_push</span></span>.

<div class="paragraph"> </div>


</li>
<li>- Here, use <span class="inlinecode"><span class="id" title="tactic">auto</span></span> to solve facts about finite sets of
              atoms, since it will simplify the <span class="inlinecode"><span class="id" title="definition">dom</span></span> function behind
              the scenes.  <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> does not work with the <span class="inlinecode"><span class="id" title="definition">dom</span></span>
              function.

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> The <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_app"><span class="id" title="constructor">typing_app</span></a></span> case follows directly from the induction
         hypotheses.

</li>
</ul>
  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_weakening_strengthened"><span class="id" title="lemma">typing_weakening_strengthened</span></a> :  <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">G</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">G</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">G</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">E</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">E'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">G</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">G0</span> <span class="id" title="var">Eq</span> <span class="id" title="var">Uniq</span>; <span class="id" title="tactic">subst</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab50"></a><h3 class="section">Demo <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_weakening"><span class="id" title="lemma">typing_weakening</span></a></span></h3>


<div class="paragraph"> </div>

    We can now prove our original statement of weakening.  The only
    interesting step is the use of the rewrite_env tactic.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_weakening"><span class="id" title="lemma">typing_weakening</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> <span class="id" title="var">F</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span> <span class="id" title="var">J</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rewrite_env</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">F</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">E</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Lec2.html#typing_weakening_strengthened"><span class="id" title="axiom">typing_weakening_strengthened</span></a>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab51"></a><h1 class="section">Substitution</h1>

<div class="paragraph"> </div>

 Having proved weakening, we can now prove the usual substitution
    lemma, which we state both in the form we need and in the
    strengthened form needed to make the proof go through.

<div class="paragraph"> </div>

<pre>
  typing_subst_simple : forall E e u S T z,
    typing ((z ~ S) ++ E) e T -&gt;
    typing E u S -&gt;
    typing E ([z ~&gt; u] e) T

  typing_subst : forall E F e u S T z,
    typing (F ++ (z ~ S) ++ E) e T -&gt;
    typing E u S -&gt;
    typing (F ++ E) ([z ~&gt; u] e) T
</pre>

<div class="paragraph"> </div>

    The proof of the strengthened statement proceeds by induction on
    the given typing derivation for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.  The most involved case is
    the one for variables; the others follow from the induction
    hypotheses.

<div class="paragraph"> </div>

<a name="lab52"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_subst_var_case"><span class="id" title="lemma">typing_subst_var_case</span></a></span></h3>


<div class="paragraph"> </div>

    Below, we state what needs to be proved in the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case
    of the substitution lemma.  Fill in the proof.

<div class="paragraph"> </div>

    Proof sketch: The proof proceeds by a case analysis on <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">==</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a>)</span>,
    i.e., whether the two variables are the same or not.

<div class="paragraph"> </div>

<ul class="doclist">
<li> If <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a>)</span>, then we need to show <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#E"><span class="id" title="variable">E</span></a>)</span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a>)</span>.
        This follows from the given typing derivation for <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#u"><span class="id" title="variable">u</span></a></span> by
        weakening and the fact that <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a></span> must equal <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a></span>.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">≠</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a>)</span>, then we need to show <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a></span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#E"><span class="id" title="variable">E</span></a>)</span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#T"><span class="id" title="variable">T</span></a>)</span>.
        This follows by the typing rule for variables.

</li>
</ul>

<div class="paragraph"> </div>

    HINTS: Lemmas <span class="inlinecode"><span class="id" title="var">binds_mid_eq</span></span>, <span class="inlinecode"><span class="id" title="var">uniq_remove_mid</span></span>,
    and <span class="inlinecode"><span class="id" title="var">binds_remove_mid</span></span> are useful.

<div class="paragraph"> </div>

  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_subst_var_case"><span class="id" title="lemma">typing_subst_var_case</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> <span class="id" title="var">F</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">u</span> <span class="id" title="var">S</span> <span class="id" title="var">T</span> (<span class="id" title="var">z</span> <span class="id" title="var">x</span> : <span class="id" title="abbreviation">atom</span>),<br/>
&nbsp;&nbsp;<span class="id" title="definition">binds</span> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="inductive">uniq</span> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec2.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a>) <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">u</span> <span class="id" title="var">S</span> <span class="id" title="var">T</span> <span class="id" title="var">z</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span> <span class="id" title="var">J</span> <span class="id" title="var">K</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab53"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_subst"><span class="id" title="lemma">typing_subst</span></a></span></h3>


<div class="paragraph"> </div>

    Complete the proof of the substitution lemma. The proof proceeds
    by induction on the typing derivation for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.  The initial steps
    should use <span class="inlinecode"><span class="id" title="var">remember</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> and <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> in a manner
    similar to the proof of weakening.

<div class="paragraph"> </div>

   HINTS:
<ul class="doclist">
<li> Use the lemma proved above for the <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case.

<div class="paragraph"> </div>


</li>
<li> The <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case follows from the induction hypothesis.
<ul class="doclist">
<li>- Use <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> to simplify the substitution.

<div class="paragraph"> </div>


</li>
<li>- In order to use the induction hypothesis, use <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#subst_var"><span class="id" title="lemma">subst_var</span></a></span>
             to push the substitution under the opening operation.

<div class="paragraph"> </div>


</li>
<li>- Recall the lemma <span class="inlinecode"><span class="id" title="var">typing_to_lc_c</span></span> and the <span class="inlinecode"><span class="id" title="var">rewrite_env</span></span>
             and <span class="inlinecode"><span class="id" title="var">simpl_env</span></span> tactics.

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> The <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_app"><span class="id" title="constructor">typing_app</span></a></span> case follows from the induction hypotheses.
        Use <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> to simplify the substitution.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_subst"><span class="id" title="lemma">typing_subst</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> <span class="id" title="var">F</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">u</span> <span class="id" title="var">S</span> <span class="id" title="var">T</span> (<span class="id" title="var">z</span> : <span class="id" title="abbreviation">atom</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="Stlc.Lec2.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec2.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab54"></a><h3 class="section">Exercise <span class="inlinecode"><span class="id" title="var">typing_subst_simpl</span></span></h3>


<div class="paragraph"> </div>

    Complete the proof of the substitution lemma stated in the form we
    need it.  The proof is similar to that of <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_weakening"><span class="id" title="lemma">typing_weakening</span></a></span>.

<div class="paragraph"> </div>

    HINT: You'll need to use <span class="inlinecode"><span class="id" title="var">rewrite_env</span></span> to prepend <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a></span>,
    and <span class="inlinecode"><span class="id" title="var">simpl_env</span></span> to simplify nil away.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_subst_simple"><span class="id" title="lemma">typing_subst_simple</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">u</span> <span class="id" title="var">S</span> <span class="id" title="var">T</span> (<span class="id" title="var">z</span> : <span class="id" title="abbreviation">atom</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Stlc.Lec2.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec2.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a>) <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab55"></a><h1 class="section">Preservation</h1>

<div class="paragraph"> </div>

<a name="lab56"></a><h3 class="section">Exercise (Recommended)</h3>


<div class="paragraph"> </div>

    Complete the proof of preservation.  In this proof, we proceed by
    induction on the given typing derivation.  The induction
    hypothesis has already been appropriately generalized by the given
    proof fragment.

<div class="paragraph"> </div>

    Proof sketch: By induction on the typing derivation for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case: Variables don't step.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case: Abstractions don't step.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_app"><span class="id" title="constructor">typing_app</span></a></span> case: By case analysis on how <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span> steps. The
        <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#step_beta"><span class="id" title="constructor">step_beta</span></a></span> case is interesting, since it follows by the
        substitution lemma.  The others follow directly from the
        induction hypotheses.

</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="preservation"><span class="id" title="lemma">preservation</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> : <a class="idref" href="Stlc.Definitions.html#ctx"><span class="id" title="definition">ctx</span></a>) <span class="id" title="var">e</span> <span class="id" title="var">e'</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#e'"><span class="id" title="variable">e'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e'"><span class="id" title="variable">e'</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">e'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">e'</span> <span class="id" title="var">J</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab57"></a><h1 class="section">Progress</h1>

<div class="paragraph"> </div>

<a name="lab58"></a><h3 class="section">Exercise</h3>


<div class="paragraph"> </div>

    Complete the proof of the progress lemma.  The induction
    hypothesis has already been appropriately generalized by the given
    proof fragment.

<div class="paragraph"> </div>

    Proof sketch: By induction on the typing derivation for <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a></span> case: Can't happen; the empty context doesn't
        bind anything.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a></span> case: Abstractions are values.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#typing_app"><span class="id" title="constructor">typing_app</span></a></span> case: Applications reduce.  The result follows
        from an exhaustive case analysis on whether the two components
        of the application step or are values and the fact that a
        value must be an abstraction.

</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="progress"><span class="id" title="lemma">progress</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#is_value"><span class="id" title="definition">is_value</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">∃</span></a> <span class="id" title="var">e'</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#e'"><span class="id" title="variable">e'</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="var">e</span> <span class="id" title="var">T</span>); <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> (<span class="id" title="abbreviation">atom</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>)) <span class="id" title="keyword">as</span> <span class="id" title="var">E</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>.<br/>

<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab59"></a><h1 class="section">Tactic support</h1>

<div class="paragraph"> </div>

 When picking a fresh var or applying a rule that uses cofinite
    quantification, choosing a set of vars to be fresh for can be
    tedious.  In practice, it is simpler to use a tactic to choose the
    set to be as large as possible.

<div class="paragraph"> </div>

    The tactic <span class="inlinecode"><span class="id" title="var">gather_atoms</span></span> is used to collect together all the
    atoms in the context.  It relies on an auxiliary tactic,
    <span class="inlinecode"><span class="id" title="var">gather_atoms_with</span></span> (from MetatheoryAtom), which maps a function
    that returns a finite set of atoms over all hypotheses with the
    appropriate type.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">gather_atoms</span> ::=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">A</span> := <span class="id" title="var">gather_atoms_with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="abbreviation">atoms</span> ⇒ <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">B</span> := <span class="id" title="var">gather_atoms_with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="abbreviation">atom</span> ⇒ <span class="id" title="abbreviation">singleton</span> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">C</span> := <span class="id" title="var">gather_atoms_with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<span class="id" title="abbreviation">var</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Stlc.Definitions.html#typ"><span class="id" title="inductive">typ</span></a>) ⇒ <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">D</span> := <span class="id" title="var">gather_atoms_with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a> ⇒ <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">A</span> <span class="id" title="notation">`</span><span class="id" title="notation">union</span><span class="id" title="notation">`</span> <span class="id" title="var">B</span> <span class="id" title="notation">`</span><span class="id" title="notation">union</span><span class="id" title="notation">`</span> <span class="id" title="var">C</span> <span class="id" title="notation">`</span><span class="id" title="notation">union</span><span class="id" title="notation">`</span> <span class="id" title="var">D</span>).<br/>

<br/>
</div>

<div class="doc">
A number of other, useful tactics are defined by the Metatheory
    library, and each depends on <span class="inlinecode"><span class="id" title="var">gather_atoms</span></span>.  By redefining
    <span class="inlinecode"><span class="id" title="var">gather_atoms</span></span>, denoted by the <span class="inlinecode">::=</span> in its definition below, we
    automatically update these tactics so that they use the proper
    notion of "all atoms in the context."

<div class="paragraph"> </div>

    For example, the tactic <span class="inlinecode">(<span class="id" title="var">pick</span></span> <span class="inlinecode"><span class="id" title="tactic">fresh</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>)</span> chooses an atom fresh for
    "everything" in the context.  It is the same as <span class="inlinecode">(<span class="id" title="var">pick</span></span> <span class="inlinecode"><span class="id" title="tactic">fresh</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><span class="id" title="keyword">for</span></span>
    <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#L"><span class="id" title="variable">L</span></a>)</span>, except where <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#L"><span class="id" title="variable">L</span></a></span> has been computed by <span class="inlinecode"><span class="id" title="var">gather_atoms</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab60"></a><h1 class="section">Renaming</h1>

<div class="paragraph"> </div>

 Substitution and weakening together give us a property we call
   renaming: (see <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#typing_rename"><span class="id" title="lemma">typing_rename</span></a></span> <span class="inlinecode"><span class="id" title="var">below</span></span> that we can change the name
   of the variable used to open an expression in a typing
   derivation. In practice, this means that if a variable is not
   "fresh enough" during a proof, we can use this lemma to rename it
   to one with additional freshness constraints.

<div class="paragraph"> </div>

   Renaming is used below to show the correspondence between the
   exists-fresh version of the rules with the cofinite version, and
   also to show that typechecking is decidable.

<div class="paragraph"> </div>

 However, before we prove renaming, we need an auxiliary lemma about
    typing judgments which says that terms are well-typed only in
    unique contexts.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_uniq"><span class="id" title="lemma">typing_uniq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="inductive">uniq</span> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "typing_abs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="inductive">uniq</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <span class="id" title="notation">¬</span> <span class="id" title="var">T1</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">G</span>)); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">solve_uniq</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Demo: the proof of renaming.

<div class="paragraph"> </div>

   Note that this proof does not proceed by induction: even if we add
   new typing rules to the language, as long as the weakening and
   substution properties hold we can use this proof.

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="typing_rename"><span class="id" title="lemma">typing_rename</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="abbreviation">atom</span>) <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) (<a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) (<a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec2.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span> <span class="id" title="var">Fr1</span> <span class="id" title="var">Fr2</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">x</span> <span class="id" title="notation">==</span> <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "x = y".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "x &lt;&gt; y".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">J</span> : <span class="id" title="inductive">uniq</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <span class="id" title="notation">¬</span> <span class="id" title="var">T1</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">E</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Lec2.html#typing_uniq"><span class="id" title="lemma">typing_uniq</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">J'</span> : <span class="id" title="inductive">uniq</span> <span class="id" title="var">E</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">J</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (@<a class="idref" href="Stlc.Lec1.html#subst_exp_intro"><span class="id" title="axiom">subst_exp_intro</span></a> <span class="id" title="var">x</span>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rewrite_env</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><span class="id" title="var">y</span> <span class="id" title="notation">¬</span> <span class="id" title="var">T1</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <span class="id" title="var">E</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Lec2.html#typing_subst"><span class="id" title="axiom">typing_subst</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">S</span> := <span class="id" title="var">T1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">simpl_env</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">SCase</span> "(open x s) is well-typed".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Lec2.html#typing_weakening_strengthened"><span class="id" title="axiom">typing_weakening_strengthened</span></a>. <span class="id" title="tactic">eauto</span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">SCase</span> "y is well-typed".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Definitions.html#typing_var"><span class="id" title="constructor">typing_var</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab61"></a><h2 class="section">Exercise: Exists-Fresh Definition</h2>

<div class="paragraph"> </div>

 The use of cofinite quantification may make some people worry that we
    are not formalizing the "right" language. Below, we show that
    the "exists-fresh" version of the rules is the same as the cofinite
    version. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_abs_exists"><span class="id" title="lemma">typing_abs_exists</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">atom</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">¬</span> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a>) (<a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec2.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a>) (<a class="idref" href="Stlc.Definitions.html#typ_arrow"><span class="id" title="constructor">typ_arrow</span></a> <a class="idref" href="Stlc.Lec2.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="Stlc.Lec2.html#T2"><span class="id" title="variable">T2</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Definitions.html#typing_abs"><span class="id" title="constructor">typing_abs</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">L</span> := <span class="id" title="definition">dom</span> <span class="id" title="var">E</span> <span class="id" title="notation">\</span><span class="id" title="notation">u</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <span class="id" title="var">e</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span> <span class="id" title="var">Fr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Stlc.Lec2.html#typing_rename"><span class="id" title="lemma">typing_rename</span></a> <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span>:=<span class="id" title="var">x</span>); <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="exists_cofinite"><span class="id" title="lemma">exists_cofinite</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="cofinite_exists"><span class="id" title="lemma">cofinite_exists</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Lec2.html#typing_e"><span class="id" title="inductive">typing_e</span></a> <a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.  <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab62"></a><h2 class="section">Additional Exercises</h2>

<div class="paragraph"> </div>

<a name="lab63"></a><h3 class="section">Challenge Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#fv_in_dom"><span class="id" title="lemma">fv_in_dom</span></a></span></h3>


<div class="paragraph"> </div>

   We also want a property that states that the free variables of well-typed
   terms are contained within the domain of their typing contexts.

<div class="paragraph"> </div>

 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="fv_in_dom"><span class="id" title="lemma">fv_in_dom</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">G</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec2.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec2.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">[&lt;=]</span> <span class="id" title="definition">dom</span> <a class="idref" href="Stlc.Lec2.html#G"><span class="id" title="variable">G</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>