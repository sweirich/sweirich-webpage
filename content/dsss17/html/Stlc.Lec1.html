<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Stlc.Lec1</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Stlc.Lec1</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab20"></a><h1 class="section">Language specification and variable binding</h1>

<div class="paragraph"> </div>

 This tutorial demonstrates the use of the Coq proof assistant for
    reasoning about higher-order programming languages, such as those based
    on the lambda calculus, and their implementations. We use a
    simply-typed lambda calculus as a running example.

<div class="paragraph"> </div>

    Reasoning about languages with first-class functions is difficult because
    of variable binding. In particular, there are two important
    complications that make working with lambda-terms difficult.

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, we would like to work up to <i>alpha-equivalence</i>. In other words, we
    would like our reasoning about lambda terms to not depend on the names
    that we use for free variables.

<div class="paragraph"> </div>

    For example, we would like to show that these two terms are
    indistinguishable to the semantics

<div class="paragraph"> </div>

              \x.x  and  \y.y

<div class="paragraph"> </div>


</li>
<li> Second, substitution should be <i>capture avoiding</i>. When we substitute
    terms with free variables, those free variables should never become bound
    by the terms they are being substituted into. This means that sometimes we
    need to rename bound variables to avoid capture. For example,

<div class="paragraph"> </div>

            <span class="inlinecode"></span> <span class="inlinecode"><a class="idref" href="Stlc.Lec2.html#z"><span class="id" title="variable">z</span></a></span> <span class="inlinecode">~&gt;</span> <span class="inlinecode">\<span class="id" title="var">x.y</span></span> <span class="inlinecode"></span>(\y.z)     should be     \y1.\x.y

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab21"></a><h2 class="section">Approaches to variable binding</h2>

<div class="paragraph"> </div>

 Unfortunately, variable binding is an <i>old</i> problem. The issue isn't that
    we don't know how to solve this problem, in fact there are <i>many</i>, <i>many</i>
    different ways to solve this problem and they all have their trade offs.
    I won't include an entire taxonomy of solutions here, but before we go
    further, I want to mention a few relevant alternatives.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Only working with closed terms, never reasoning about equivalence

</li>
</ul>

<div class="paragraph"> </div>

    If we never have to substitute an <i>open</i> term, then we never have to worry
    about variable capture. We can represent binding variables in lambda terms
    using names in a straightforward manner. This approach is the simplest and
    side-steps the two problems shown above. For example, it can be used to
    show type soundness, as is done in Software Foundations.

<div class="paragraph"> </div>

    However, this approach does not scale. For example, reasoning about
    compiler optimizations requires reasoning about the equivalence of
    transformed open terms.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Named terms, with swapping

</li>
</ul>

<div class="paragraph"> </div>

    We can still work with named terms, even in the presence of free
    variables, as long as we <i>define</i> alpha equivalence and substitution
    appropriately. There are, again, many approaches to these definitions.
    However, the most elegant approach is inspired by Nominal Logic.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Locally nameless representation (LN)

</li>
</ul>

<div class="paragraph"> </div>

    When working in Coq, it is convenient to use a representation that makes
    all alpha-equivalent terms <i>definitionally</i> equivalent. LN does this while
    still providing an interface that is mostly similar to paper proofs.

<div class="paragraph"> </div>

Other approaches to variable binding include: de Bruijn indices, de Bruijn
levels, weak HOAS, PHOAS, locally named, canonically named... etc. Of these,
de Bruijn representations are by far the most commonly used representation in
Coq.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

In this tutorial, we will promote the following approach to variable binding.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Use a locally nameless representation to <i>specify</i> and reason about the
  semantics

<div class="paragraph"> </div>


</li>
<li> Use a named representation to <i>implement</i> environment-based interpreters for
  lambda calculus terms. If binders are mostly unique, then this
  implementation avoids additional work.

<div class="paragraph"> </div>


</li>
<li> The definitions, lemmas and proofs that are needed to work with
  lambda-calculus terms are highly automatable.

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

In the first part of the tutorial, we will demonstrate the use of a locally
nameless representation to reason about a specification of a call-by-name
lambda calculus. We will state the operational semantics of this language
using a small-step substitution-based inductive relation.  We will use this
specification for metatheoretic reasoning: we will prove <i>preservation</i> and
<i>progress</i> as in Software Foundations.

<div class="paragraph"> </div>

Next, we will represent the same language using a <i>nominal representation</i> but
specify the semantics using an abstract machine. This abstract machine is
given as a Coq function from machine configurations to machine configurations,
and can be used as an efficient interpreter. This abstract machine features a
heap (i.e. runtime environment for variables) so we will not need to define
capture-avoiding substitution as part of our semantics.

<div class="paragraph"> </div>

Finally, we will prove that the abstract machine implements the same semantics
as the locally nameless based substitution semantics.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

The development of this tutorial draws from two coordinating tools that
support working with LN representations.

<div class="paragraph"> </div>

The Ott tool provides a direct way of generating LN language definitions from
a simple specification language.  The file <span class="inlinecode"><span class="id" title="var">stlc.ott</span></span> contains the input
specification of the language of this tutorial.  <span class="inlinecode"><span class="id" title="var">Definitions.v</span></span> is a
commented version of the Ott output. (For comparison, the raw output is in
<span class="inlinecode"><span class="id" title="var">Stlc.v</span></span>).  The same specifications can also be used to produce LaTeX macros
for typesetting language definitions, demonstrated in <span class="inlinecode"><span class="id" title="var">stlc.pdf</span></span>.

<div class="paragraph"> </div>

The LNgen tool works with Ott to generate a number of lemmas and auxiliary
definitions for working with LN terms. The file <span class="inlinecode"><span class="id" title="var">Lemmas.v</span></span> is commented
version of that output. (For comparison, the raw output is in <span class="inlinecode"><span class="id" title="var">Stlc_inf.v</span></span>.)

<div class="paragraph"> </div>

<a name="lab22"></a><h1 class="section">The simply-typed lambda calculus in Coq.</h1>

<div class="paragraph"> </div>

 First, we import a number of definitions from the Metatheory library
    (see Metatheory.v).  The following command makes those definitions
    available in the rest of this file.

<div class="paragraph"> </div>

    This command will only succeed if you have already run <span class="inlinecode"><span class="id" title="var">make</span></span> and <span class="inlinecode"><span class="id" title="var">make</span></span>
    <span class="inlinecode"><span class="id" title="var">install</span></span> in the Metatheory directory to compile the Metatheory library. 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Metalib.Metatheory</span>.<br/>

<br/>
</div>

<div class="doc">
Next, we import the definitions of the simply-typed lambda calculus.
    If you haven't skimmed this file yet, you should do so now. You don't
    need to understand everything in the file at first, but you will need to
    refer back to it in the material below. 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="Stlc.Definitions.html#"><span class="id" title="library">Stlc.Definitions</span></a>.<br/>

<br/>
</div>

<div class="doc">
And some notations (defined in `Stlc.Definitions`), but not automatically
    brought into scope. 
</div>
<div class="code">
<span class="id" title="keyword">Import</span> <span class="id" title="var">StlcNotations</span>.<br/>

<br/>
</div>

<div class="doc">
For the examples below, we introduce some sample variable names to
    play with. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="X"><span class="id" title="definition">X</span></a> : <span class="id" title="axiom">atom</span> := <span class="id" title="axiom">fresh</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="Y"><span class="id" title="definition">Y</span></a> : <span class="id" title="axiom">atom</span> := <span class="id" title="axiom">fresh</span> (<a class="idref" href="Stlc.Lec1.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="Z"><span class="id" title="definition">Z</span></a> : <span class="id" title="axiom">atom</span> := <span class="id" title="axiom">fresh</span> (<a class="idref" href="Stlc.Lec1.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h2 class="section">Encoding STLC terms</h2>

<div class="paragraph"> </div>

 We start with examples of encodings in STLC.

<div class="paragraph"> </div>

  For example, we can encode the expression <span class="inlinecode">(\<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>.</span> <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>)</span> as below. We use the
  index <span class="inlinecode">0</span> because it refers to the closest <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> to the bound variable
  occurrence. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="demo_rep1"><span class="id" title="definition">demo_rep1</span></a> := <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0)).<br/>
</div>

<div class="doc">
                     ^                        |                                         |                        |                   <hr/>
                   
<div class="paragraph"> </div>

  Here is another example: the encoding of <span class="inlinecode">(\<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>.</span> <span class="inlinecode">\<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a>.</span> <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>))</span>.      
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="demo_rep2"><span class="id" title="definition">demo_rep2</span></a> := <a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 1))).<br/>
</div>

<div class="doc">
                     ^    ^              |         |                                    |    |              |         |                                    |    ----------------         |                                    |                             |              <hr/>
              
<div class="paragraph"> </div>

 Finally, here is an example where the same bound variable has two
    different indices, and the same index refers to two different
    bound variables.
                         <span class="inlinecode">\<a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a>.</span> <span class="inlinecode">((\<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a>.</span> <span class="inlinecode">(<a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a>))</span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#y"><span class="id" title="variable">y</span></a>)</span>                        
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="demo_rep3"><span class="id" title="definition">demo_rep3</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 1))) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0)).<br/>
</div>

<div class="doc">
        ^         ^              |         |           |                   |         |              |         |           |                   |         ----------------         |           |                   |                                  |           |          <hr/>
          
<div class="paragraph"> </div>

<a name="lab24"></a><h3 class="section">Exercise: term representation</h3>


<div class="paragraph"> </div>

    Define the following lambda calculus terms using the locally
	 nameless representation.

<div class="paragraph"> </div>

       "two" : \s. \z. s (s z)

<div class="paragraph"> </div>

       "COMB_K" : \x. \y. x

<div class="paragraph"> </div>

       "COMB_S" : \x. \y. \z. x z (y z)

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
There are two important advantages of the locally nameless
    representation:
<ul class="doclist">
<li> Alpha-equivalent terms have a unique representation.
       We're always working up to alpha-equivalence.

</li>
<li> Operations such as free variable substitution and free
       variable calculation have simple recursive definitions
       (and therefore are simple to reason about).

</li>
</ul>

<div class="paragraph"> </div>

    Weighed against these advantages are two drawbacks:
<ul class="doclist">
<li> The <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#exp"><span class="id" title="inductive">exp</span></a></span> datatype admits terms, such as <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> <span class="inlinecode">3</span>, where
       indices are unbound.
       A term is called "locally closed" when it contains
       no unbound indices.

</li>
<li> We must define *both* bound variable &amp; free variable
       substitution and reason about how these operations
       interact with each other.

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab25"></a><h2 class="section">Substitution</h2>

<div class="paragraph"> </div>

 The substitution function replaces a free variable with a term.  For
    simplicity, we define a notation for free variable substitution that
    mimics standard mathematical notation.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Z"><span class="id" title="definition">Z</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">](</span></a><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0)(<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>))<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
To demonstrate how free variable substitution works, we need to
    reason about var equality.

</div>
<div class="code">
<span class="id" title="keyword">Check</span> (<a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a> <span class="id" title="notation">==</span> <a class="idref" href="Stlc.Lec1.html#Z"><span class="id" title="definition">Z</span></a>).<br/>

<br/>
</div>

<div class="doc">
The decidable var equality function returns a sum. If the two
    vars are equal, the left branch of the sum is returned, carrying
    a proof of the proposition that the vars are equal.  If they are
    not equal, the right branch includes a proof of the disequality.

<div class="paragraph"> </div>

    The demo below uses three new tactics:
<ul class="doclist">
<li> The tactic <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> reduces a Coq expression to its normal
      form.

</li>
<li> The tactic <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode">(<a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>==<a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>)</span> considers the two possible
      results of the equality test.

</li>
<li> The tactic <span class="inlinecode"><span class="id" title="var">Case</span></span> marks cases in the proof script.
      It takes any string as its argument, and puts that string in
      the hypothesis list until the case is finished.
      (This tactic is completely optional.)

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="demo_subst1"><span class="id" title="lemma">demo_subst1</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Z"><span class="id" title="definition">Z</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0) (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>))<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0) (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Z"><span class="id" title="definition">Z</span></a>))<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a><span class="id" title="notation">==</span><a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>).<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "left".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "right".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab26"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#subst_eq_var"><span class="id" title="lemma">subst_eq_var</span></a></span></h3>


<div class="paragraph"> </div>

    We can use almost the same proof script as
    above to show how substitution works in the variable case. Try it
    on your own.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_eq_var"><span class="id" title="lemma">subst_eq_var</span></a>: <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">u</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">](</span></a><a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab27"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#subst_neq_var"><span class="id" title="lemma">subst_neq_var</span></a></span></h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_neq_var"><span class="id" title="lemma">subst_neq_var</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">u</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">](</span></a><a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#subst_same"><span class="id" title="lemma">subst_same</span></a></span></h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_same"><span class="id" title="lemma">subst_same</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span> <span class="id" title="var">e</span>, <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab29"></a><h2 class="section">Free variables</h2>

<div class="paragraph"> </div>

 The function <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a></span> calculates the set of free variables in an
    expression.  This function returns a value of type `atoms` --- a finite
    set of variable names.  
<div class="paragraph"> </div>

 Demo <span class="inlinecode"><span class="id" title="var">fsetdec</span></span>

<div class="paragraph"> </div>

   The tactic <span class="inlinecode"><span class="id" title="var">fsetdec</span></span> solves a certain class of propositions
   involving finite sets. See the documentation in <span class="inlinecode"><span class="id" title="var">FSetWeakDecide</span></span>
   for a full specification.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fsetdec_demo"><span class="id" title="lemma">fsetdec_demo</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="axiom">atom</span>) (<span class="id" title="var">S</span> : <span class="id" title="abbreviation">atoms</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="keyword">in</span><span class="id" title="notation">`</span> <span class="id" title="notation">(</span><span class="id" title="abbreviation">singleton</span> <a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">union</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Lec1.html#S"><span class="id" title="variable">S</span></a><span class="id" title="notation">)</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">fsetdec</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab30"></a><h3 class="section">Recommended Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a></span></h3>


<div class="paragraph"> </div>

    To show the ease of reasoning with these definitions, we will prove a
    standard result from lambda calculus: if a variable does not appear free
    in a term, then substituting for it has no effect.

<div class="paragraph"> </div>

    HINTS: Prove this lemma by induction on <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> You will need to use <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> in many cases.  You can <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> everything
      everywhere (including hypotheses) with the pattern <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode">×</span>.

<div class="paragraph"> </div>


</li>
<li> Part of this proof includes a false assumption about free variables.
      Destructing this hypothesis produces a goal about finite set membership
      that is solvable by <span class="inlinecode"><span class="id" title="var">fsetdec</span></span>.

<div class="paragraph"> </div>


</li>
<li> The <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> tactic converts a goal of the form <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#e1'"><span class="id" title="variable">e1'</span></a></span> in to
      one of the form <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#e1'"><span class="id" title="variable">e1'</span></a></span>, and similarly for <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e1"><span class="id" title="variable">e1</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e2"><span class="id" title="variable">e2</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#e1'"><span class="id" title="variable">e1'</span></a></span> <span class="inlinecode"><span class="id" title="var">e2'</span></span>,
      etc.  
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_exp_fresh_eq"><span class="id" title="lemma">subst_exp_fresh_eq</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">e</span> <span class="id" title="var">u</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab31"></a><h2 class="section">Additional Exercises</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

   Step through the proof that free variables are not introduced by substitution.

<div class="paragraph"> </div>

   This proof actually is very automatable (<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode">*;</span> <span class="inlinecode"><span class="id" title="tactic">auto</span>.</span> takes care of
   all but the var_f case), but the explicit proof below demonstrates two
   parts of the finite set library. These two parts are the tactic
   <span class="inlinecode"><span class="id" title="var">destruct_notin</span></span> and the lemma <span class="inlinecode"><span class="id" title="abbreviation">notin_union</span></span>, both defined in the module
   <span class="inlinecode"><span class="id" title="var">FSetWeakNotin</span></span>.

<div class="paragraph"> </div>

   Before stepping through this proof, you should go to that module to read
   about those definitions and see what other finite set reasoning is
   available.

<div class="paragraph"> </div>

  
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="fv_exp_subst_exp_notin"><span class="id" title="lemma">fv_exp_subst_exp_notin</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">u</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a><a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">u</span> <span class="id" title="var">e</span> <span class="id" title="var">Fr1</span> <span class="id" title="var">Fr2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "var_b".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "var_f".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">x0</span> <span class="id" title="notation">==</span> <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "abs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHe</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "app".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">destruct_notin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="abbreviation">notin_union</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHe1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHe2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now prove the following properties of substitution and fv 
<div class="paragraph"> </div>

<a name="lab32"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_fresh_same"><span class="id" title="lemma">subst_exp_fresh_same</span></a></span></h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_exp_fresh_same"><span class="id" title="lemma">subst_exp_fresh_same</span></a> :<br/>
<span class="id" title="keyword">∀</span> <span class="id" title="var">u</span> <span class="id" title="var">e</span> <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab33"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#fv_exp_subst_exp_fresh"><span class="id" title="lemma">fv_exp_subst_exp_fresh</span></a></span></h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fv_exp_subst_exp_fresh"><span class="id" title="lemma">fv_exp_subst_exp_fresh</span></a> :<br/>
<span class="id" title="keyword">∀</span> <span class="id" title="var">e</span> <span class="id" title="var">u</span> <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="notation">[=]</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab34"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#fv_exp_subst_exp_upper"><span class="id" title="lemma">fv_exp_subst_exp_upper</span></a></span></h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="fv_exp_subst_exp_upper"><span class="id" title="lemma">fv_exp_subst_exp_upper</span></a> :<br/>
<span class="id" title="keyword">∀</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> <span class="id" title="var">x1</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#subst_exp"><span class="id" title="definition">subst_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Stlc.Lec1.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a>) <span class="id" title="notation">[&lt;=]</span> <a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">union</span><span class="id" title="notation">`</span> <span class="id" title="abbreviation">remove</span> <a class="idref" href="Stlc.Lec1.html#x1"><span class="id" title="variable">x1</span></a> (<a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab35"></a><h1 class="section">LN specific operations and relations</h1>

<div class="paragraph"> </div>

<a name="lab36"></a><h2 class="section">Opening</h2>

<div class="paragraph"> </div>

 Opening replaces an index with a term, and is defined in the Definitions
    module.

<div class="paragraph"> </div>

 This next demo shows the operation of <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a></span>.  For example, the
    locally nameless representation of the term (\y. (\x. (y x)) y) is
    <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a></span> <span class="inlinecode">1</span> <span class="inlinecode">0))</span> <span class="inlinecode">0)</span>.  To look at the body without the
    outer abstraction, we need to replace the indices that refer to
    that abstraction with a name.  Therefore, we show that we can open
    the body of the abs above with Y to produce <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a></span> <span class="inlinecode">(<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a></span> <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a></span> <span class="inlinecode">0))</span>
    <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>)</span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="demo_open"><span class="id" title="lemma">demo_open</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 1) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0))) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0)<a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">)</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0))) (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. &nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab37"></a><h2 class="section">Local closure</h2>

<div class="paragraph"> </div>

 The local closure judgement classifies terms that have *no* dangling
   indices.

<div class="paragraph"> </div>

   Step through this derivation to see why the term is locally closed.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="demo_lc"><span class="id" title="lemma">demo_lc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> (<a class="idref" href="Stlc.Definitions.html#app"><span class="id" title="constructor">app</span></a> (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>) (<a class="idref" href="Stlc.Definitions.html#var_b"><span class="id" title="constructor">var_b</span></a> 0))) (<a class="idref" href="Stlc.Definitions.html#var_f"><span class="id" title="constructor">var_f</span></a> <a class="idref" href="Stlc.Lec1.html#Y"><span class="id" title="definition">Y</span></a>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Definitions.html#lc_app"><span class="id" title="constructor">lc_app</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Definitions.html#lc_abs"><span class="id" title="constructor">lc_abs</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>. <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab38"></a><h2 class="section">Properties about basic operations</h2>

<div class="paragraph"> </div>

 The most important properties about open and lc_exp concern their
    relationship with the free variable and subst functions.

<div class="paragraph"> </div>

    For example, one important property is shown below: that we can commute
    free and bound variable substitution.

<div class="paragraph"> </div>

    We won't prove this lemma as part of the tutorial (it is proved in
    <span class="inlinecode"><span class="id" title="var">Lemmas.v</span></span>), but it is an important building block for reasoning about
    LN terms.

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a> :<br/>
<span class="id" title="keyword">∀</span> <span class="id" title="var">e3</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> <span class="id" title="var">x1</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> <a class="idref" href="Stlc.Lec1.html#e3"><span class="id" title="variable">e3</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e3"><span class="id" title="variable">e3</span></a>) (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab39"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#subst_var"><span class="id" title="lemma">subst_var</span></a></span></h3>

<div class="paragraph"> </div>

 The lemma above is most often used with <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e2"><span class="id" title="variable">e2</span></a></span> as some fresh
    variable. Therefore, it simplifies matters to define the following useful
    corollary.

<div class="paragraph"> </div>

    HINT: Do not use induction.  Rewrite with <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_open_exp_wrt_exp"><span class="id" title="lemma">subst_exp_open_exp_wrt_exp</span></a></span> and
    <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#subst_neq_var"><span class="id" title="lemma">subst_neq_var</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_var"><span class="id" title="lemma">subst_var</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">u</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a><a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">)</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">(</span></a><a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec1.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab40"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_intro"><span class="id" title="lemma">subst_exp_intro</span></a></span></h3>

<div class="paragraph"> </div>

 This next lemma states that opening can be replaced with variable
    opening and substitution.

<div class="paragraph"> </div>

    This lemma, like many about <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a></span>, should be proven
    via induction on the term <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#e"><span class="id" title="variable">e</span></a></span>. However, during this induction, the
    binding depth of the term changes, so to make sure that we have
    a flexible enough induction hypothesis, we must generalize the
    argument to <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp_rec"><span class="id" title="definition">open_exp_wrt_exp_rec</span></a></span>.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_exp_intro"><span class="id" title="lemma">subst_exp_intro</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">u</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">`</span><span class="id" title="notation">notin</span><span class="id" title="notation">`</span> <span class="id" title="notation">(</span><a class="idref" href="Stlc.Definitions.html#fv_exp"><span class="id" title="definition">fv_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">)</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#StlcNotations.open"><span class="id" title="abbreviation">open</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">](</span></a><a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">u</span> <span class="id" title="var">e</span> <span class="id" title="var">FV_EXP</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">open</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Stlc.Definitions.html#open_exp_wrt_exp"><span class="id" title="definition">open_exp_wrt_exp</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> 0.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">n0</span>; <span class="id" title="tactic">simpl</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab41"></a><h2 class="section">Forall quantification in <span class="inlinecode"><a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a></span>.</h2>

<div class="paragraph"> </div>

 Let's look more closely at lc_abs and lc_exp_ind. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Stlc.Definitions.html#lc_exp_ind"><span class="id" title="definition">lc_exp_ind</span></a>.<br/>

<br/>
</div>

<div class="doc">
The induction principle for the lc_exp relation is particularly strong
   in the abs case.

<div class="paragraph"> </div>

<pre>
 forall P : exp -&gt; Prop,
       ...
       (forall e : exp,
        (forall x : atom, lc_exp (e ^ x)) -&gt;
        (forall x : atom, P (e ^ x)) -&gt; P (abs e)) -&gt;
       ...
       forall e : exp, lc_exp e -&gt; P e
</pre>

<div class="paragraph"> </div>

  This principle says that to prove that a property holds for an abstraction,
  we can assume that the property holds for the body of the abstraction,
  opened with *any* variable that we like.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Stlc.Definitions.html#lc_abs"><span class="id" title="constructor">lc_abs</span></a>.<br/>

<br/>
</div>

<div class="doc">
However, on the other hand, when we show that an abstraction is locally
   closed, we need to show that its body is locally closed, when
   opened by any variable.

<div class="paragraph"> </div>

   That can sometimes be a problem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_lc0"><span class="id" title="lemma">subst_lc0</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">u</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">u</span> <span class="id" title="var">e</span> <span class="id" title="var">He</span> <span class="id" title="var">Hu</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">He</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "lc_var_f".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">x0</span> <span class="id" title="notation">==</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "lc_abs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="Stlc.Definitions.html#lc_abs"><span class="id" title="constructor">lc_abs</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lec1.html#subst_var"><span class="id" title="axiom">subst_var</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Here we are stuck. We don't know that <span class="inlinecode"><a class="idref" href="Stlc.Nominal.html#x0"><span class="id" title="variable">x0</span></a></span> is not equal to <span class="inlinecode"><a class="idref" href="Stlc.Connect.html#x"><span class="id" title="variable">x</span></a></span>,
    which is a preconduction for <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#subst_var"><span class="id" title="lemma">subst_var</span></a></span>.

<div class="paragraph"> </div>

    The solution is to prove an alternative introduction rule for
    local closure for abstractions.  In the current rule, we need
    to show that the body of the abstraction is locally closed,
    no matter what variable we choose for the binder.

<div class="paragraph"> </div>

<pre>
  | lc_abs : forall e,
      (forall x:var, lc_exp (open e x)) -&gt;
      lc_exp (abs e)
</pre>

<div class="paragraph"> </div>

    An easier to use lemma requires us to only show that the body
    of the abstraction is locally closed for a *single* variable.

<div class="paragraph"> </div>

    As before, we won't prove this lemma as part of the tutorial,
    (it too is proved in Lemmas.v) but we will use it as part of
    our reasoning.

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="lc_abs_exists"><span class="id" title="lemma">lc_abs_exists</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Definitions.html#5efff96aa6473948b40109ca70a323f0"><span class="id" title="notation">^</span></a> <a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#abs"><span class="id" title="constructor">abs</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
For example, with this addition, we can complete the proof above. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="subst_exp_lc_exp"><span class="id" title="lemma">subst_exp_lc_exp</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="abbreviation">var</span>) <span class="id" title="var">u</span> <span class="id" title="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> (<a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">[</span></a><a class="idref" href="Stlc.Lec1.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">~&gt;</span></a> <a class="idref" href="Stlc.Lec1.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="Stlc.Definitions.html#a604463a10cbf78096b99b157265e3e9"><span class="id" title="notation">]</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">u</span> <span class="id" title="var">e</span> <span class="id" title="var">He</span> <span class="id" title="var">Hu</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">He</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "lc_var_f".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">x0</span> <span class="id" title="notation">==</span> <span class="id" title="var">x</span>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "lc_abs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">x0</span> <span class="id" title="keyword">for</span> <span class="id" title="notation">{{</span><span class="id" title="var">x</span><span class="id" title="notation">}}</span>. &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Stlc.Lec1.html#lc_abs_exists"><span class="id" title="axiom">lc_abs_exists</span></a> <span class="id" title="var">x0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Stlc.Lec1.html#subst_var"><span class="id" title="axiom">subst_var</span></a>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">Case</span> "lc_app".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">eauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab42"></a><h2 class="section">Local closure and relations</h2>

<div class="paragraph"> </div>

 All of our semantics only hold for locally closed terms, and we can
    prove that.

<div class="paragraph"> </div>

    Sometimes, the proofs are straightforward; sometimes a little work is
    needed.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="step_lc_exp1"><span class="id" title="lemma">step_lc_exp1</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>, <a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab43"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#typing_to_lc_exp"><span class="id" title="lemma">typing_to_lc_exp</span></a></span></h3>


<div class="paragraph"> </div>

    Use <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#lc_abs_exists"><span class="id" title="lemma">lc_abs_exists</span></a></span> below to show that well-typed terms
    are locally closed. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="typing_to_lc_exp"><span class="id" title="lemma">typing_to_lc_exp</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">E</span> <span class="id" title="var">e</span> <span class="id" title="var">T</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Stlc.Definitions.html#typing"><span class="id" title="inductive">typing</span></a> <a class="idref" href="Stlc.Lec1.html#E"><span class="id" title="variable">E</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Stlc.Lec1.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab44"></a><h3 class="section">Exercise <span class="inlinecode"><a class="idref" href="Stlc.Lec1.html#step_lc_exp2"><span class="id" title="lemma">step_lc_exp2</span></a></span></h3>


<div class="paragraph"> </div>

    Use properties such as <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_intro"><span class="id" title="lemma">subst_exp_intro</span></a></span> and <span class="inlinecode"><a class="idref" href="Stlc.Lemmas.html#subst_exp_lc_exp"><span class="id" title="lemma">subst_exp_lc_exp</span></a></span>
    to show that the result of a step is <i>also</i> locally closed.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="step_lc_exp2"><span class="id" title="lemma">step_lc_exp2</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>, <a class="idref" href="Stlc.Definitions.html#step"><span class="id" title="inductive">step</span></a> <a class="idref" href="Stlc.Lec1.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Stlc.Definitions.html#lc_exp"><span class="id" title="inductive">lc_exp</span></a> <a class="idref" href="Stlc.Lec1.html#e2"><span class="id" title="variable">e2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>