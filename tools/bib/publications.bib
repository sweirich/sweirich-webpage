@string{proc = "Proceedings of the "}
@string{ACM  = "ACM"}
@string{SIGPLAN = "SIGPLAN"}

@string{cmu-cs = "Carnegie Mellon University, School of Computer Science"}
@string{cornell-cs = "Department of Computer Science, Cornell University"}
@string{dec-src = "Digital Equipment Corporation, Systems Research Center"}
@string{edin-cs = "Department of Computer Science, University of Edinburgh"}
@string{inria = "Institut National de Recherche en Informatique et Automatique (INRIA)"}
@string{yale-cs = "Yale University, Department of Computer Science"}


%% Conferences
@string{cade = "International Conference on Automated Deduction"}
@string{csl = "International Workshop on Computer Science Logic"}
@string{esop = "European Symposium on Programming"}
@string{fool = "Foundations of Object-Oriented Languages Workshop"}
@string{fpca = "Conference on Functional Programming Languages and Computer Architecture"}
@string{icalp = "International Colloquium on Automata, Languages, and Programming"}
@string{icfp = "{ACM SIGPLAN} International Conference on Functional Programming"}
@string{lfp = "{ACM} Conference on {Lisp} and Functional Programming"}
@string{lics = "{IEEE} Symposium on Logic in Computer Science"}
@string{mfps = "Mathematical Foundations of Programming Semantics"}
@string{osdi = "Symposium on Operating Systems Design and Implementation"}
@string{pldi = " {ACM SIGPLAN} Conference on Programming Language Design and Implementation"}
@string{popl = " {ACM}{SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages"}
@string{sosp = " {ACM} Symposium on Operating Systems Principles"}
@string{tacs = "Theoretical Aspects of Computer Software"}
@string{tlca = "International Conference on Typed Lambda Calculi and Applications"}
@string{sigmod = "Proc. {ACM} {SIGMOD} International
                  Conference on Management of Data"}
@string{oopsla = "{ACM} {SIGPLAN} Conference on Object-Oriented
                  Programming, Systems, Languages and Applications"}
@string{sigcomm = "Proc. {SIGCOMM} Symposium on Communications
                  Architectures and Protocols"}
@string{ieeesp = "IEEE Symposium on Research in Security and Privacy"}
@string{rtss = "Real-Time Systems Symposium"}

%% Workshops
@string{tic = "{ACM} {SIGPLAN} Workshop on Types in Compilation"}
@string{wcsss = "{ACM}{SIGPLAN} Workshop on Compiler Support for System Software"}
@string{hotos = "Workshop on Hot Topis in Operating Systems"}
@string{lctes = "Proceedings of the {ACM} {SIGPLAN} Workshop on Languages, 
                 Compilers, and Tools for Embedded Systems"}
@string{pepm = "{ACM} {SIGPLAN} Workshop on Partial Evaluation and
                  Semantics-Based Program Manipulation"}
@string{hoots = "International Workshop on Higher Order Operational Techniques in Semantics"}

%% Journals
@string{iandc = "Information and Computation"}
@string{jacm = "Journal of the {ACM}"}
@string{jfp = "Journal of Functional Programming"}
@string{mscs = "Mathematical Structures in Computer Science"}
@string{tcs = "Theoretical Computer Science"}
@string{toplas = "{ACM} Transactions on Programming Languages and Systems"}
@string{tse = "{IEEE} Transactions on Software Engineering"}
@String{j-LISP-SYMB-COMPUT      = "Lisp and Symbolic Computation"}

@string{lncs = "Lecture Notes in Computer Science"}

@string{academic = "Academic Press"}
@string{addison = "Addison-Wesley"}
@string{cambridge-press = "Cambridge University Press"}
@string{chapman = "Chapman \& Hall"}
@string{elsevier = "Elsevier"}
@string{mit-press = "The MIT Press"}
@string{noholland = "North-Holland"}
@string{springer = "Springer-Verlag"}
@string{sigplan-notices = "{SIGPLAN} Notices"}
@string{cam-ma = "Cambridge, Massachusetts"}
@string{ith-ny = "Ithaca, New York"}
@string{pgh-pa = "Pittsburgh, Pennsylvania"}

@string{o1="First "}
@string{o2="Second "}
@string{o3="Third "}
@string{o4="Fourth "}
@string{o5="Fifth "}
@string{o6="Sixth "}
@string{o7="Seventh "}
@string{o8="Eighth "}
@string{o9="Ninth "}
@string{o10="Tenth "}
@string{o11="Eleventh "}
@string{o12="Twelfth "}
@string{o13="Thirteenth "}
@string{o14="Fourteenth "}
@string{o15="Fifteenth "}
@string{o16="Sixteenth "}
@string{o17="Seventeenth "}
@string{o18="Eighteenth "}
@string{o19="Nineteenth "}
@string{o20="Twentieth "}
@string{o21="Twenty-First "}
@string{o22="Twenty-Second "}
@string{o23="Twenty-Third "}
@string{o24="Twenty-Fourth "}
@string{o25="Twenty-Fifth "}
@string{o26="Twenty-Sixth "}
@string{o27="Twenty-Seventh "}


%% Ack for downloaded bib entry

@String{ack-nhfb = "Nelson H. F. Beebe,
                    Center for Scientific Computing,
                    University of Utah,
                    Department of Mathematics, 322 INSCC,
                    155 S 1400 E RM 233,
                    Salt Lake City, UT 84112-0090, USA,
                    Tel: +1 801 581 5254,
                    FAX: +1 801 585 1640, +1 801 581 4148,
                    e-mail: \path|beebe@math.utah.edu|,
                            \path|beebe@acm.org|,
                            \path|beebe@ieee.org| (Internet),
                    URL: \path|http://www.math.utah.edu/~beebe/|"}


{ACM} {SIGPLAN}-{SIGACT}



@string{dl = "http://www.cis.upenn.edu/~sweirich/papers/"}
@string{tdl = "http://www.cs.cornell.edu/talc/papers/"}


@Unpublished{washburn+:mtr,  
  author = 		  {Geoff Washburn and Stephanie Weirich},
  title = 		  {Unifying nominal and structural ad-hoc 
                  polymorphism ({E}xtended version) },
  institution =  {University of Pennsylvania},
  year = 		  2003,
  month =		  oct,
  ps =           
"http://www.cis.upenn.edu/~geoffw/research/papers/esop-tr-draft.ps",
  pdf = 
"http://www.cis.upenn.edu/~geoffw/research/papers/esop-tr-draft.pdf",

  abstract = "Ad-hoc polymorphism allows the execution of programs to depend on type
information. In modern systems, it is useful for implementing generic
operations over data structures, such as equality, marshalling, or
traversal.  In the past, there have been two different forms of ad-hoc
polymorphism. The nominal form dispatches on the name of the type
argument, whereas the structural form operates by decomposing the
structure of types. In languages with user-defined types, these two
approaches are very different. Operations defined by the nominal
approach are ``open''---they must be extended with specialized
branches for user-defined types. In contrast, structurally defined
operations are closed to extension. They automatically apply to
user-defined types by treating them as their underlying definitions.
Both approaches have their benefits, so it important to provide both
capabilities in a language. Therefore we present an expressive
language that supports both forms of ad-hoc polymorphism in a single
framework.  Among the language's features are the ability to define
both ``open'' and ``closed'' operations with a single mechanism, the
ability to naturally restrict the domain of type-analyzing operations,
and new mechanisms for defining higher-order polytypism and
manipulating generative type definitions."
}

@Unpublished{weirich:erasure-hota,
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-Order Intensional Type Analysis 
                  in Type Erasure Semantics},
  note = 		  {Submitted for publication},
  month =		  jul,
  year =			  2003,
  ps =           dl # "erasure/erasure-paper-july03.ps",
  pdf =          dl # "erasure/erasure-paper-july03.pdf",
  abstract =     { Higher-order intensional type analysis is a way of defining
  type-indexed operations, such as map, fold and zip, based on
  run-time type information. However, languages supporting this
  facility are naturally defined with a type-passing semantics, which
  suffers from a number of drawbacks. This paper, describes how to
  recast higher-order intensional type analysis in a type-erasure
  semantics.  The resulting language is simple and easy to
  implement---we present a prototype implementation of the necessary
  machinery as a small Haskell library.}
}

@TechReport{washburn+:itabox-tr,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism
                   {(Extended version)} },
  institution =  {Dept. of Computer and Information Science, 
                   University of Pennsylvania},
  year = 		  2003,
  number =		  {MS-CIS-03-26},
  month =		  sep,
  ps =           dl # "itabox/MS-CIS-03-26.ps",
  pdf =          dl # "itabox/MS-CIS-03-26.pdf",
  annote =       "This paper is an extended version 
                  of \cite{washburn+:itabox}."
}

@InProceedings{washburn+:itabox,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism},
  booktitle =	  icfp,
  pages =		  {249--262},
  year =			  2003,
  address =		  {Uppsala, Sweden},
  month =		  aug,
  note =    "An extended 
       version of this paper is \cite{washburn+:itabox-tr}", 
  ps =           dl # "itabox/icfp-published-version.ps",
  pdf =          dl # "itabox/icfp-published-version.pdf",

  abstract = {Higher-order abstract syntax is a simple technique for
implementing languages with functional programming.  Object variables
and binders are implemented by variables and binders in the host
language.  By using this technique, one can avoid implementing common
and tricky routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System \Fw.
This encoding can serve as a starting point for reasoning about
higher-order structures in polymorphic languages.  } }


@PhdThesis{weirich:phd,
  author = 		  {Stephanie Weirich},
  title = 		  {Programming With Types},
  school = 		  {Cornell University},
  month =        aug,
  year =         2002,
  ps =           dl # "thesis/thesis.ps",
  pdf =          dl # "thesis/thesis.pdf",
  abstract = 
     "Run-time type analysis is an increasingly important linguistic
     mechanism in modern programming languages. Language runtime
     systems use it to implement services such as accurate garbage
     collection, serialization, cloning and structural
     equality. Component frameworks rely on it to provide reflection
     mechanisms so they may discover and interact with program
     interfaces dynamically. Run-time type analysis is also crucial
     for large, distributed systems that must be dynamically extended,
     because it allows those systems to check program invariants when
     new code and new forms of data are added. Finally, many generic
     user-level algorithms for iteration, pattern matching, and
     unification can be defined through type analysis mechanisms.

     However, existing frameworks for run-time type analysis were
     designed for simple type systems. They do not scale well to the
     sophisticated type systems of modern and next-generation
     programming languages that include complex constructs such as
     first-class abstract types, recursive types, objects, and type
     parameterization. In addition, facilities to support type
     analysis often require complicated language semantics that allow
     little freedom in their implementation.  This dissertation
     investigates the foundations of run-time type analysis in the
     context of statically-typed, polymorphic programming languages.
     Its goal is to show how such a language may support
     type-analyzing operations in a way that balances expressiveness,
     safety and simplicity."

}

@InProceedings{weirich:hota,
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-Order Intensional Type Analysis},
  booktitle = 	  {11th European Symposium on Programming},
  editor =		  {Daniel Le M\'{e}tayer},
  pages =        {98--114},
  year =         2002,
  month =        apr,
  address =      {Grenoble, France},
  ps =           dl # "hota/hota.ps",
  pdf =          dl # "hota/hota.pdf",

  abstract = "Intensional type analysis provides the ability to
     analyze abstracted types at run time. In this paper, we extend
     that ability to higher-order and kind-polymorphic type
     constructors. The resulting language is elegant and expressive:
     we show through examples how it extends the repertoire of
     polytypic functions that may be defined."
}


@Article{crary+:intensional-journal,
  author    = {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title     = "Intensional Polymorphism in Type Erasure Semantics",
  journal   = jfp,
  month     = nov,
  year      = {2002},
  volume    = 12,
  number    = 6,
  pages     = {567--600},
  abstract  = "Intensional polymorphism, the ability to dispatch to
     different routines based on types at run time, enables a variety
     of advanced implementation techniques for polymorphic languages,
     including tag-free garbage collection, unboxed function
     arguments, polymorphic marshalling, and flattened data
     structures. To date, languages that support intensional
     polymorphism have required a type-passing (as opposed to
     type-erasure) interpretation where types are constructed and
     passed to polymorphic functions at run time. Unfortunately,
     type-passing suffers from a number of drawbacks; it requires
     duplication of constructs at the term and type levels, it
     prevents abstraction, and it severely complicates polymorphic
     closure conversion.  We present a type-theoretic framework that
     supports intensional polymorphism, but avoids many of the
     disadvantages of type passing. In our approach, run-time type
     information is represented by ordinary terms. This avoids the
     duplication problem, allows us to recover abstraction, and avoids
     complications with closure conversion. In addition, our type
     system provides another improvement in expressiveness; it allows
     unknown types to be refined in place thereby avoiding certain
     beta-expansions required by other frameworks."
}

@inproceedings{weirich01,
  author =      "Stephanie Weirich",
  title =       {Encoding Intensional Type Analysis},
  booktitle =   "10th European Symposium on Programming",
  year =        2001,
  series =      lncs,
  volume =       2028,
  editor =      "D. Sands",
  publisher =   "Springer",
  pages =       {92--106},
  address =     {Genova, Italy},
  annote =        "© 2001 Springer-Verlag. Minor corrections in local version.",
  url =         "http://link.springer.de/link/service/series/0558/tocs/t2028.htm",
  dvi =          dl # "depabs/depabs.dvi",
  ps =          dl # "depabs/depabs.ps",
  pdf =         dl # "depabs/depabs.pdf",

  abstract = "Languages for intensional type analysis permit ad-hoc
     polymorphism, or run-time analysis of types. However, such
     languages require complex, specialized constructs to support this
     operation, which hinder optimization and complicate the
     meta-theory of these languages. In this paper, we observe that
     such specialized operators need not be intrinsic to the language,
     and in fact, their operation may be simulated through standard
     encodings of iteration in the polymorphic lambda
     calculus. Therefore, we may more easily add intensional analysis
     operators to complicated languages via a translation semantics,
     instead of through language extension."  }

@inproceedings{weirich00,
  author =       "Stephanie Weirich",
  title  =       "Type-Safe Cast: Functional Pearl",
  booktitle =    proc # o5 # icfp,
  year =         2000,
  month =        sep,
  address =      "Montreal, Canada",
  pages =        "58--67",

  abstract = "In a language with non-parametric or ad-hoc
    polymorphism, it is possible to determine the identity of a type
    variable at run time.  With this facility, we can write a function
    to convert a term from one abstract type to another, if the two
    hidden types are identical.  However, the naive implementation of
    this function requires that the term be destructed and rebuilt. In
    this paper, we show how to eliminate this overhead using
    higher-order type abstraction. We demonstrate this solution in two
    frameworks for ad-hoc polymorphism: intensional type analysis and
    type classes.", 
  dvi = dl # "cast/cast.dvi", 
  ps = dl # "cast/cast.ps",
  pdf = dl # "cast/cast.pdf"
  }

@InProceedings{crary00,
  author =	 {Karl Crary and Stephanie Weirich},
  title =	 "Resource Bound Certification",
  booktitle =	 o27 # " " # popl,
  pages =	 {184--198},
  year =	 2000,
  address =	 "Boston, MA, USA",
  month =	 jan,
  dvi =          dl # "res/res.dvi",
  pdf =          dl # "res/res.pdf",
  ps =          dl # "res/res.ps.gz",


  abstract = "Various code certification systems allow the
    certification and static verification of a variety of important
    safety properties such as memory safety and control-flow
    safety. These systems provide valuable tools for verifying that
    untrusted and potentially malicious code is safe before execution.
    However, one important safety property that is not usually
    included is that programs adhere to specific bounds on resource
    consumption, such as running time.

    We present a decidable type system capable of specifying and
    certifying bounds on resource consumption. Our system makes two
    advances over previous resource bound certification systems, both
    of which are necessary for a practical system: we allow the
    execution time of programs and their subroutines to vary,
    depending on their arguments, and we provide a fully automatic
    compiler generating certified executables from source-level
    programs. The principal device in our approach is a strategy for
    simulating dependent types using sum and inductive kinds. "
}

@inproceedings{morrisett+:talx86,
  author =	 "Greg Morrisett and Karl Crary and Neal Glew and Dan
                  Grossman and Richard Samuels and Frederick Smith and
                  David Walker and Stephanie Weirich and Steve
                  Zdancewic",
  title =	 "{TALx86}: A Realistic Typed Assembly Language",
  booktitle =	 o2 # " " # wcsss,
  year =	 1999,
  month =	 may,
  pages =        "25--35",
  note =         "Published as {INRIA} research report number 0228, March 1999.",
  address =	 "Atlanta, GA, USA",
  dvi =           tdl #  "talx86-wcsss.dvi",
  ps =           tdl #  "talx86-wcsss.ps.gz",

  abstract = "The goal of typed assembly language (TAL) is to provide
     a low-level, statically typed target language that is better
     suited than Java bytecodes for supporting a wide variety of
     source languages and a number of important optimizations. In
     previous work, we formalized idealized versions of TAL and proved
     important safety properties about them. In this paper, we present
     our progress in defining and implementing a realistic typed
     assembly language called TALx86. The TALx86 instructions comprise
     a relatively complete fragment of the Intel IA32 (32-bit 80x86
     flat model) assembly language and are thus executable on
     processors such as the Intel Pentium. The type system for the
     language incorporates a number of advanced features necessary for
     safely compiling large programs to good code.

     To motivate the design of the type system, we demonstrate how
     various high-level language features are compiled to TALx86. For
     this purpose, we present a type-safe C-like language called
     Popcorn.",
}


@inproceedings{crary+:lx,
  author =	 "Karl Crary and Stephanie Weirich",
  title =	 "Flexible Type Analysis",
  booktitle =	 proc # o4 # icfp,
  year =	 1999,
  month =	 sep,
  address =	 "Paris, France",
  pages =	 "233--248",

  abstract = "Run-time type dispatch enables a variety of advanced
     optimization techniques for polymorphic languages, including
     tag-free garbage collection, unboxed function arguments, and
     flattened data structures.  However, modern type-preserving
     compilers transform types between stages of compilation, making
     type dispatch prohibitively complex at low levels of typed
     compilation. It is crucial therefore for type analysis at these
     low levels to refer to the types of previous
     stages. Unfortunately, no current intermediate language supports
     this facility.

     To fill this gap, we present the language LX, which provides a
     rich language of type constructors supporting type analysis
     (possibly of previous-stage types) as a programming idiom. This
     language is quite flexible, supporting a variety of other
     applications such as analysis of quantified types, analysis with
     incomplete type information, and type classes. We also show that
     LX is compatible with a type-erasure semantics.",

   dvi =      dl # "lx/lxpaper.dvi",
   ps  =      dl # "lx/lxpaper.ps.gz",
   pdf =      dl # "lx/lxpaper.pdf"
}

@InProceedings{crary+:intensional,
  author = 	 {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = 	 "Intensional Polymorphism in Type Erasure Semantics",
  booktitle = 	 proc # o3 # icfp,
  year =	 1998,
  address =	 {Baltimore, MD, USA},
  month =	 sep,
  pages =   "301--313",
  note =    "An extended and revised version of this paper is \cite{crary+:intensional-journal}", 
                 
  ps = dl # "typepass/typepass.ps"
}



@TechReport{crary98a,
  author = 	 {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = 	 {Intensional Polymorphism in Type Erasure Semantics (Extended Version)},
  institution =  {Cornell University},
  year = 	 1998,
  number =	 {TR98-1721},
  month =	 nov,
  ps = dl # "typepass/typepass-tr.ps",
  note =     "This paper is superceded by \cite{crary+:intensional-journal}."
}


@inproceedings{hicks00,
  author = "Michael Hicks and Stephanie Weirich and Karl Crary",
  title =  "Safe and Flexible Dynamic Linking of Native Code",
  booktitle = "Types in Compilation: Third International Workshop, TIC 2000;
               Montreal, Canada, September 21, 2000; Revised Selected Papers",
  editor = "R. Harper",
  publisher = "Springer", 
  year = 2001,
  series = lncs,
  volume = 2071, 
  pages = {147--176},
  annote = "Related technical report: Michael Hicks and Stephanie
     Weirich.  A calculus for dynamic loading. Technical Report
     MS-CIS-00-07, University of Pennsylvania, April 2000.",

  abstract = "We present the design and implementation of the first
     complete framework for flexible and safe dynamic linking of
     native code. Our approach extends Typed Assembly Language with a
     primitive for loading and typechecking code, which is flexible
     enough to support a variety of linking strategies, but simple
     enough that it does not significantly expand the trusted
     computing base. Using this primitive, along with the ability to
     compute with types, we show that we can program many existing
     dynamic linking approaches. As a concrete demonstration, we have
     used our framework to implement dynamic linking for a type-safe
     dialect of C, closely modeled after the standard linking facility
     for Unix C programs. Aside from the unavoidable cost of
     verification, our implementation performs comparably with the
     standard, untyped approach.",

  url = "http://link.springer.de/link/service/series/0558/tocs/t2071.htm",
  ps = dl # "taldynlink/taldynlink.ps.gz",
  pdf = dl # "taldynlink/taldynlink.pdf"
  
}

@inproceedings{flanagan96, 
   author = "Cormac Flanagan and Matthew Flatt and Shriram
             Krishnamurthi and Stephanie Weirich and Matthias
             Felleisen",
   title =  "Catching Bugs in the Web of Program Invariants",
   booktitle = proc # pldi,
   year = 1996,
   pages = "23--32",
   abstract = "MrSpidey is a user-friendly, interactive static
     debugger for Scheme. A static debugger supplements the standard
     debugger by analyzing the program and pinpointing those program
     operations tha may cause run-time errors suce as dereferencing
     the null pointer or applying non-functions. The program analysis
     of MrSpidey computes value set descriptions for each term in the
     program and constructs a value flow graph connecting the set
     descriptions. Using the set descriptions, MrSpidey can identify
     and highlight potentially erroneous program operations, whose
     cause the programmer can the explore by selectively exposing
     portions of the value flow graph.",

   PS = dl # "pldi96-ffkwf_ps.gz"
}

